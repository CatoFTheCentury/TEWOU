/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ var __webpack_modules__ = ({

/***/ "../../engine/source/_games.ts"
/*!*************************************!*\
  !*** ../../engine/source/_games.ts ***!
  \*************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Games: () => (/* binding */ Games)\n/* harmony export */ });\n/* harmony import */ var _alacrity_incarnations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./alacrity/_incarnations */ \"../../engine/source/alacrity/_incarnations.ts\");\n/* harmony import */ var _alacrity_bodies__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./alacrity/_bodies */ \"../../engine/source/alacrity/_bodies.ts\");\n/* harmony import */ var _systems_keyboard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./systems/keyboard */ \"../../engine/source/systems/keyboard.ts\");\n/* harmony import */ var _systems_physics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./systems/physics */ \"../../engine/source/systems/physics.ts\");\n/* harmony import */ var _render_assets__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./render/assets */ \"../../engine/source/render/assets.ts\");\n/* harmony import */ var _render_composite__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./render/composite */ \"../../engine/source/render/composite.ts\");\n/* harmony import */ var _systems_camera__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./systems/camera */ \"../../engine/source/systems/camera.ts\");\n/* harmony import */ var _render_shaderloader__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./render/shaderloader */ \"../../engine/source/render/shaderloader.ts\");\n/* harmony import */ var _render_render__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./render/_render */ \"../../engine/source/render/_render.ts\");\n/* harmony import */ var _systems_window__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./systems/window */ \"../../engine/source/systems/window.ts\");\n/* harmony import */ var _alacrity_gameobjects__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./alacrity/_gameobjects */ \"../../engine/source/alacrity/_gameobjects.ts\");\n/* harmony import */ var _parsers_ganiParser__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./parsers/ganiParser */ \"../../engine/source/parsers/ganiParser.ts\");\n/* harmony import */ var _physics_capture__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./physics/capture */ \"../../engine/source/physics/capture.ts\");\n/* harmony import */ var _physics_npcCollision__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./physics/npcCollision */ \"../../engine/source/physics/npcCollision.ts\");\n/* harmony import */ var _render_shaders_normal__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./render/shaders/normal */ \"../../engine/source/render/shaders/normal.ts\");\n/* harmony import */ var _render_shaders_reverser__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./render/shaders/reverser */ \"../../engine/source/render/shaders/reverser.ts\");\n/* harmony import */ var _render_shaders_whitetransparent__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./render/shaders/whitetransparent */ \"../../engine/source/render/shaders/whitetransparent.ts\");\n/* harmony import */ var _physics_gridCollision__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./physics/gridCollision */ \"../../engine/source/physics/gridCollision.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar Games;\r\n(function (Games) {\r\n    class Generic {\r\n        constructor(target, width, height, shaders = [new _render_shaders_normal__WEBPACK_IMPORTED_MODULE_14__.Normal(), new _render_shaders_reverser__WEBPACK_IMPORTED_MODULE_15__.Reverser(), new _render_shaders_whitetransparent__WEBPACK_IMPORTED_MODULE_16__.WhiteTransparent()]) {\r\n            this.alacritypool = [];\r\n            this.systempool = [];\r\n            this.paused = false;\r\n            this.rootfolder = \"_assets/\";\r\n            this.fileextensions = [\"png\", \"gani\", \"wav\", \"csv\"];\r\n            this.currentLevel = undefined;\r\n            this.remoteobjects = {};\r\n            this.loadedobjcount = 0;\r\n            this.glContext = new _render_render__WEBPACK_IMPORTED_MODULE_8__.Render.GLContext(target, width + \"\", height + \"\");\r\n            this.shadercontext = new _render_shaderloader__WEBPACK_IMPORTED_MODULE_7__.ShaderLoader(this.glContext.gl, shaders);\r\n            Generic.gamespool.push(this);\r\n            this.gameid = Generic.gamespool.length - 1;\r\n            this.window = new _systems_window__WEBPACK_IMPORTED_MODULE_9__.Window(this.glContext);\r\n            this.window.frame = new _render_composite__WEBPACK_IMPORTED_MODULE_5__.Composite.Frame(this.glContext, this.shadercontext, []);\r\n            this.window.frame.rprops.srcrect = { x: 0, y: 0, w: this.glContext.gl.canvas.width, h: this.glContext.gl.canvas.height };\r\n            this.window.frame.rprops.shaderID = \"reverser\";\r\n        }\r\n        async load() { await this.initialize(); }\r\n        async initialize(keyboard = true, touch = true) {\r\n            if (keyboard)\r\n                new _systems_keyboard__WEBPACK_IMPORTED_MODULE_2__.Keyboard();\r\n            // console.log(this.fileextensions);\r\n            if (this.fileextensions.length > 0) {\r\n                if (this.gamefolder == undefined || this.gamefolder == \"\")\r\n                    await Promise.all(await _render_assets__WEBPACK_IMPORTED_MODULE_4__.Assets.loadAllExtInFolder(this.rootfolder, this.fileextensions));\r\n                else\r\n                    await Promise.all(await _render_assets__WEBPACK_IMPORTED_MODULE_4__.Assets.loadAllExtInFolder(this.rootfolder + this.gamefolder + '/', this.fileextensions));\r\n                await Promise.all(await _render_assets__WEBPACK_IMPORTED_MODULE_4__.Assets.loadAllExtInFolder(this.rootfolder + '_debug/', this.fileextensions));\r\n            }\r\n            await this.shadercontext.init();\r\n        }\r\n        run(sharedobjects) {\r\n            for (let i = this.loadedobjcount; i < sharedobjects.length; i++) {\r\n                let newobj = sharedobjects[i];\r\n                if (newobj.owner.id == this.gameid)\r\n                    continue;\r\n                let invocation = new _alacrity_gameobjects__WEBPACK_IMPORTED_MODULE_10__.GameObjects.SharedObject(newobj);\r\n                invocation.presence = new _alacrity_incarnations__WEBPACK_IMPORTED_MODULE_0__.Incarnations.Incarnated(new _render_composite__WEBPACK_IMPORTED_MODULE_5__.Composite.Frame(this.glContext, this.shadercontext, []));\r\n                invocation.presence.pos = invocation.pos;\r\n                invocation.presence.dir = invocation.dir;\r\n                invocation.presence.anims = this.loadAnims(invocation.anisrc);\r\n                invocation.presence.switchAnimation(invocation.currentani);\r\n                this.remoteobjects[sharedobjects[i].id] = invocation;\r\n                this.gameframe.frame.push(invocation.presence.myFrame);\r\n            }\r\n            this.loadedobjcount = sharedobjects.length;\r\n            for (let s of this.systempool) {\r\n                s.refresh();\r\n            }\r\n            for (let o of sharedobjects) {\r\n                let tomod = this.remoteobjects[o.id];\r\n                if (tomod) {\r\n                    tomod.presence.switchAnimation(o.currentani);\r\n                    tomod.presence.dir = o.dir;\r\n                    tomod.presence.myFrame.rprops.pos = o.pos;\r\n                }\r\n            }\r\n            if (!this.paused)\r\n                this.refreshAlacrities();\r\n            _alacrity_bodies__WEBPACK_IMPORTED_MODULE_1__.Bodies.Alacrity.resetAllMovements(this.alacritypool);\r\n        }\r\n        refreshAlacrities() {\r\n            this.alacritypool = this.alacritypool.filter((a) => !a.delete);\r\n            for (let i = 0; i < this.alacritypool.length; i++) {\r\n                this.alacritypool[i].update();\r\n            }\r\n            for (let i = 0; i < this.alacritypool.length; i++) {\r\n                this.alacritypool[i].finalize();\r\n            }\r\n        }\r\n        loadAnims(src) {\r\n            let animations = {};\r\n            for (let s in src) {\r\n                let file = src[s];\r\n                let ani = _parsers_ganiParser__WEBPACK_IMPORTED_MODULE_11__.GaniParser.parse(_render_assets__WEBPACK_IMPORTED_MODULE_4__.Assets.getText(file)).animations;\r\n                let aniarr = [];\r\n                for (let a of ani) {\r\n                    aniarr.push(this.buildAni(a));\r\n                }\r\n                animations[s] = aniarr;\r\n            }\r\n            return animations;\r\n        }\r\n        async newTiledLevel(levelindex) {\r\n            if (this.currentLevel !== undefined) {\r\n                for (let r of this.currentLevel.representation) {\r\n                    r.rprops.delete = true;\r\n                }\r\n                for (let b of this.currentLevel.bodies) {\r\n                    b.myFrame.rprops.delete = true;\r\n                }\r\n            }\r\n            let level = this.levels[levelindex];\r\n            await level.load();\r\n            return level;\r\n        }\r\n        displayLevel(level) {\r\n            if (this.gameframe == undefined) {\r\n                this.gameframe = new _render_composite__WEBPACK_IMPORTED_MODULE_5__.Composite.Frame(this.glContext, this.shadercontext, [\r\n                    ...level.representation,\r\n                    ...level.bodies.map((a) => a.myFrame),\r\n                    // Debug.Grid.see(collisiongrid, {x:0,y:0,w:40*16,h:40*16})\r\n                ]);\r\n                this.gameframe.camera = new _systems_camera__WEBPACK_IMPORTED_MODULE_6__[\"default\"](this.srcview, { x: 0, y: 0, ...level.levelsize });\r\n            }\r\n            else {\r\n                this.gameframe.camera.setBounds({ x: 0, y: 0, ...level.levelsize });\r\n                this.gameframe.addToComposition([\r\n                    ...level.representation,\r\n                    ...level.bodies.map((a) => a.myFrame),\r\n                ]);\r\n            }\r\n        }\r\n        buildAni(anibuild) {\r\n            let anim = new _render_composite__WEBPACK_IMPORTED_MODULE_5__.Composite.Animation(this.glContext, this.shadercontext, []);\r\n            for (let f of anibuild.frames) {\r\n                anim.frames.push(this.buildSnap(f));\r\n            }\r\n            return anim;\r\n        }\r\n        buildSnap(snapbuild) {\r\n            let snap = new _render_composite__WEBPACK_IMPORTED_MODULE_5__.Composite.Snap(this.glContext, this.shadercontext, []);\r\n            for (let p of snapbuild) {\r\n                snap.parts.push(new _render_composite__WEBPACK_IMPORTED_MODULE_5__.Composite.Image(this.glContext, this.shadercontext, p.file, p.srcrect, p.dstrect));\r\n            }\r\n            return snap;\r\n        }\r\n        newFrame(contents) {\r\n            return new _render_composite__WEBPACK_IMPORTED_MODULE_5__.Composite.Frame(this.glContext, this.shadercontext, contents);\r\n        }\r\n        newRectangle(bounds, color) {\r\n            return new _render_composite__WEBPACK_IMPORTED_MODULE_5__.Composite.Rectangle(this.glContext, this.shadercontext, bounds, color);\r\n        }\r\n        newSnap(contents) {\r\n            return new _render_composite__WEBPACK_IMPORTED_MODULE_5__.Composite.Snap(this.glContext, this.shadercontext, contents);\r\n        }\r\n        newText(text, properties = {}) {\r\n            return new _render_composite__WEBPACK_IMPORTED_MODULE_5__.Composite.Text(this.glContext, this.shadercontext, text, properties);\r\n        }\r\n        registerEntity(entity, frame = this.window.frame) {\r\n            this.alacritypool.push(entity);\r\n            frame.addToComposition([entity.myFrame]);\r\n        }\r\n    }\r\n    Generic.gamespool = [];\r\n    Games.Generic = Generic;\r\n    class Physical extends Generic {\r\n        async initialize(keyboard = true, touch = true) {\r\n            await super.initialize(keyboard, touch);\r\n            this.gamephysics = new _systems_physics__WEBPACK_IMPORTED_MODULE_3__.Physics();\r\n            this.systempool.push(this.gamephysics);\r\n        }\r\n        async newTiledLevel(leveln) {\r\n            let level = await super.newTiledLevel(leveln);\r\n            return level;\r\n        }\r\n        addCapture(captureProperties) {\r\n            this.gamephysics.collisionpool.push(new _physics_capture__WEBPACK_IMPORTED_MODULE_12__.Capture(captureProperties.collideswith, captureProperties.type, captureProperties.owner, captureProperties.hitbox, captureProperties.oncollision));\r\n        }\r\n        addAsCollision(incarnation, from, cwith, type) {\r\n            this.gamephysics.collisionpool.push(new _physics_npcCollision__WEBPACK_IMPORTED_MODULE_13__.NPCCollision(incarnation, from, cwith, type));\r\n        }\r\n        addGrid(boolArr, resolution, cwith, type) {\r\n            this.gamephysics.collisionpool.push(new _physics_gridCollision__WEBPACK_IMPORTED_MODULE_17__.CollisionGrid(boolArr, resolution, cwith, type));\r\n        }\r\n    }\r\n    class Action extends Physical {\r\n        async newTiledLevel(leveln) {\r\n            let level = await super.newTiledLevel(leveln);\r\n            return level;\r\n        }\r\n    }\r\n    Games.Action = Action;\r\n})(Games || (Games = {}));\r\n\n\n//# sourceURL=webpack:///../../engine/source/_games.ts?\n}");

/***/ },

/***/ "../../engine/source/_type.ts"
/*!************************************!*\
  !*** ../../engine/source/_type.ts ***!
  \************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RunSwitch: () => (/* binding */ RunSwitch)\n/* harmony export */ });\nvar RunSwitch;\r\n(function (RunSwitch) {\r\n    RunSwitch[RunSwitch[\"off\"] = 0] = \"off\";\r\n    RunSwitch[RunSwitch[\"disabled\"] = 1] = \"disabled\";\r\n    RunSwitch[RunSwitch[\"enabled\"] = 2] = \"enabled\";\r\n    RunSwitch[RunSwitch[\"running\"] = 3] = \"running\";\r\n    RunSwitch[RunSwitch[\"elapsed\"] = 4] = \"elapsed\";\r\n})(RunSwitch || (RunSwitch = {}));\r\n\n\n//# sourceURL=webpack:///../../engine/source/_type.ts?\n}");

/***/ },

/***/ "../../engine/source/alacrity/_bodies.ts"
/*!***********************************************!*\
  !*** ../../engine/source/alacrity/_bodies.ts ***!
  \***********************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Bodies: () => (/* binding */ Bodies)\n/* harmony export */ });\n/* harmony import */ var _time__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./time */ \"../../engine/source/alacrity/time.ts\");\n/* harmony import */ var _render_composite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../render/composite */ \"../../engine/source/render/composite.ts\");\n/* harmony import */ var _physics_states__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../physics/states */ \"../../engine/source/physics/states.ts\");\n\r\n\r\n\r\nvar Bodies;\r\n(function (Bodies) {\r\n    class Alacrity {\r\n        constructor() {\r\n            this.lifetime = new _time__WEBPACK_IMPORTED_MODULE_0__.Time.Timeout([Infinity], 'lifetime');\r\n            this.delete = false;\r\n            this.triggers = [];\r\n            this.timeouts = [];\r\n        }\r\n        finalize() { }\r\n        resetMovementVector() { }\r\n        static resetAllMovements(pool) {\r\n            for (let a of pool) {\r\n                a.resetMovementVector();\r\n            }\r\n        }\r\n        update() {\r\n            this.timeouts = this.timeouts.filter((t) => {\r\n                if (t.deletion)\r\n                    return false;\r\n                this.triggers.push(t.test());\r\n                return true;\r\n            });\r\n        }\r\n        addTimeout(durations, actions, repeat = true, continuous = true) {\r\n            let timeout = new _time__WEBPACK_IMPORTED_MODULE_0__.Time.Timeout(durations, \"noname\", { continuous: continuous, repeat: repeat }, actions);\r\n            this.timeouts.push(timeout);\r\n            return timeout;\r\n        }\r\n        destroy() {\r\n            this.delete = true;\r\n        }\r\n        react(owner, name, params) { return false; }\r\n    }\r\n    Bodies.Alacrity = Alacrity;\r\n    class UIElement extends Alacrity {\r\n        constructor(animation) {\r\n            super();\r\n            this.hitbox = { x: 0, y: 0, w: 0, h: 0 };\r\n            this.pos = { x: 0, y: 0 };\r\n            this.hidden = false;\r\n            this.myAnim = animation;\r\n            for (let m of this.myAnim.frames) {\r\n                m.rprops.pos = this.pos;\r\n            }\r\n            // this.myAnim.rprops.pos = this.pos;\r\n            this.myAnim.rprops.hidden = this.hidden;\r\n        }\r\n    }\r\n    Bodies.UIElement = UIElement;\r\n    class Existence extends Alacrity {\r\n        constructor() {\r\n            super(...arguments);\r\n            this.pos = { x: 0, y: 0 };\r\n            this.hitbox = { x: 0, y: 0, w: 0, h: 0 };\r\n        }\r\n    }\r\n    Bodies.Existence = Existence;\r\n    class Embodiment extends Existence {\r\n        constructor(frame) {\r\n            super();\r\n            this.collisions = [];\r\n            this.activeeffects = [1, 1, 1, 1];\r\n            this.flip = { flipx: false, flipy: false };\r\n            let fr;\r\n            if (!(frame instanceof _render_composite__WEBPACK_IMPORTED_MODULE_1__.Composite.Frame)) {\r\n                if (Array.isArray(frame)) {\r\n                    fr = new _render_composite__WEBPACK_IMPORTED_MODULE_1__.Composite.Frame(frame[0].glContext, frame[0].shadercontext, frame);\r\n                }\r\n                else {\r\n                    fr = new _render_composite__WEBPACK_IMPORTED_MODULE_1__.Composite.Frame(frame.glContext, frame.shadercontext, [frame]);\r\n                }\r\n            }\r\n            else {\r\n                fr = frame;\r\n            }\r\n            this.myFrame = fr;\r\n            // this.myFrame.rprops.pos = this.pos;\r\n            // if(this.myFrame.rprops.layer == -1) this.myFrame.rprops.layer = .5;\r\n            this.myFrame.rprops.flip = this.flip;\r\n        }\r\n        destroy() {\r\n            this.delete = true;\r\n            this.myFrame.rprops.delete = true;\r\n            for (let c of this.collisions) {\r\n                c.deleteMe = true;\r\n            }\r\n        }\r\n        finalize() {\r\n            if (this.myFrame.rprops.pos.x != this.pos.x || this.myFrame.rprops.pos.y != this.pos.y) {\r\n                this.myFrame.setPosition(this.pos);\r\n            }\r\n            super.finalize();\r\n        }\r\n    }\r\n    Bodies.Embodiment = Embodiment;\r\n    class Mobility extends Embodiment {\r\n        constructor() {\r\n            super(...arguments);\r\n            this.movementvector = { x: 0, y: 0 };\r\n            this.speed = .2;\r\n            this.velocity = new Set();\r\n            this.normalgravity = { strength: .075, x: 0, y: 1 };\r\n            this.destination = null;\r\n            this.movetimer = new _time__WEBPACK_IMPORTED_MODULE_0__.Time.Timeout([Infinity], \"move\");\r\n            this.movecallback = () => { };\r\n        }\r\n        finalize() {\r\n            if (this.destination != null) {\r\n                // console.log(this.movetimer.test().state)\r\n                // console.log(this.movetimer.end)\r\n                if ((Math.abs(this.pos.x - this.destination.x) < 1 &&\r\n                    Math.abs(this.pos.y - this.destination.y) < 1) ||\r\n                    this.movetimer.test().state == \"triggered\") {\r\n                    this.destination = null;\r\n                    this.movecallback();\r\n                }\r\n                else {\r\n                    let distance = {\r\n                        x: this.destination.x - this.pos.x,\r\n                        y: this.destination.y - this.pos.y\r\n                    };\r\n                    if (distance.x != 0 || distance.y != 0) {\r\n                        let length = Math.sqrt(distance.x * distance.x +\r\n                            distance.y * distance.y);\r\n                        if (length > 0) {\r\n                            this.movementvector.x += distance.x / length;\r\n                            this.movementvector.y += distance.y / length;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            let movement = {\r\n                x: this.movementvector.x * this.speed * _time__WEBPACK_IMPORTED_MODULE_0__.Time.Delta.delta,\r\n                y: this.movementvector.y * this.speed * _time__WEBPACK_IMPORTED_MODULE_0__.Time.Delta.delta,\r\n            };\r\n            for (let g of this.velocity) {\r\n                movement.x += g.x * g.strength * _time__WEBPACK_IMPORTED_MODULE_0__.Time.Delta.delta;\r\n                movement.y += g.y * g.strength * _time__WEBPACK_IMPORTED_MODULE_0__.Time.Delta.delta;\r\n            }\r\n            if ((movement.x < 0 && !(this.activeeffects[1] & _physics_states__WEBPACK_IMPORTED_MODULE_2__.CollideTypes.block)) ||\r\n                (movement.x > 0 && !(this.activeeffects[3] & _physics_states__WEBPACK_IMPORTED_MODULE_2__.CollideTypes.block))) {\r\n                this.pos.x += movement.x;\r\n            }\r\n            if ((movement.y < 0 && !(this.activeeffects[0] & _physics_states__WEBPACK_IMPORTED_MODULE_2__.CollideTypes.block)) ||\r\n                (movement.y > 0 && !(this.activeeffects[2] & _physics_states__WEBPACK_IMPORTED_MODULE_2__.CollideTypes.block))) {\r\n                this.pos.y += movement.y;\r\n            }\r\n            super.finalize();\r\n        }\r\n        resetMovementVector() {\r\n            this.movementvector = { x: 0, y: 0 };\r\n        }\r\n        movetowards(destination, during = Infinity, callback = () => { }) {\r\n            this.destination = destination;\r\n            this.movetimer.ms = [during];\r\n            // console.log(during);\r\n            this.movetimer.restart();\r\n            this.movecallback = callback;\r\n        }\r\n    }\r\n    Bodies.Mobility = Mobility;\r\n})(Bodies || (Bodies = {}));\r\n\n\n//# sourceURL=webpack:///../../engine/source/alacrity/_bodies.ts?\n}");

/***/ },

/***/ "../../engine/source/alacrity/_gameobjects.ts"
/*!****************************************************!*\
  !*** ../../engine/source/alacrity/_gameobjects.ts ***!
  \****************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameObjects: () => (/* binding */ GameObjects)\n/* harmony export */ });\n/* harmony import */ var _incarnations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_incarnations */ \"../../engine/source/alacrity/_incarnations.ts\");\n/* harmony import */ var _parsers_iniparser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parsers/iniparser */ \"../../engine/source/parsers/iniparser.ts\");\n/* harmony import */ var _systems_keyboard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../systems/keyboard */ \"../../engine/source/systems/keyboard.ts\");\n/* harmony import */ var _render_assets__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../render/assets */ \"../../engine/source/render/assets.ts\");\n/* harmony import */ var _parsers_tiledParser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../parsers/tiledParser */ \"../../engine/source/parsers/tiledParser.ts\");\n\r\n\r\n\r\n\r\n\r\nvar GameObjects;\r\n(function (GameObjects) {\r\n    class Level {\r\n        constructor() {\r\n            this.bodies = [];\r\n        }\r\n        async load() {\r\n            this.cellbuild = await _parsers_iniparser__WEBPACK_IMPORTED_MODULE_1__.IniParser.loadIni(\"_assets/\" + this.ininame);\r\n            this.levelsize = { w: this.cellbuild.tiles[0].tileYX[0].length * this.cellbuild.square.w, h: this.cellbuild.tiles[0].tileYX.length * this.cellbuild.square.h };\r\n        }\r\n        async buildCell(file, glContext, shadercontext) {\r\n            this.cellbuild = await _parsers_iniparser__WEBPACK_IMPORTED_MODULE_1__.IniParser.loadIni(file);\r\n            this.cellbuild.texture = _render_assets__WEBPACK_IMPORTED_MODULE_3__.Assets.retrieveTex(this.cellbuild.tileset, glContext);\r\n            this.levelsize = { w: this.cellbuild.tiles[0].tileYX[0].length * this.cellbuild.square.w, h: this.cellbuild.tiles[0].tileYX.length * this.cellbuild.square.h };\r\n            this.representation = _parsers_tiledParser__WEBPACK_IMPORTED_MODULE_4__.Tiled.blit(glContext, shadercontext, this.cellbuild, \"level-layer\");\r\n        }\r\n    }\r\n    GameObjects.Level = Level;\r\n    class SharedObject {\r\n        constructor(shared) {\r\n            this.anisrc = {};\r\n            this.pos = shared.pos;\r\n            this.anisrc = shared.anisrc;\r\n            this.currentani = shared.currentani;\r\n            this.hitbox = shared.hitbox;\r\n            this.ownerid = shared.owner.id;\r\n            this.ownername = shared.owner.name;\r\n            this.dir = shared.dir;\r\n        }\r\n        update() {\r\n        }\r\n    }\r\n    GameObjects.SharedObject = SharedObject;\r\n    class Fauna extends _incarnations__WEBPACK_IMPORTED_MODULE_0__.Incarnations.Fauna {\r\n    }\r\n    GameObjects.Fauna = Fauna;\r\n    class Player extends _incarnations__WEBPACK_IMPORTED_MODULE_0__.Incarnations.Incarnated {\r\n        constructor() {\r\n            super(...arguments);\r\n            this.hp = { max: 3, current: 3 };\r\n            this.keyboardactions = {};\r\n        }\r\n        registerKey(key, actions) {\r\n            this.keyboardactions[key] = actions;\r\n        }\r\n        updateKeys() {\r\n            for (let k in this.keyboardactions) {\r\n                let keyactions = this.keyboardactions[k];\r\n                if (_systems_keyboard__WEBPACK_IMPORTED_MODULE_2__.Keyboard.keys[k] != undefined) {\r\n                    switch (_systems_keyboard__WEBPACK_IMPORTED_MODULE_2__.Keyboard.keys[k]) {\r\n                        case -1:\r\n                            if (keyactions.keyup != undefined)\r\n                                keyactions.keyup();\r\n                            break;\r\n                        case 0:\r\n                            break;\r\n                        case 1:\r\n                            if (keyactions.keydown != undefined)\r\n                                keyactions.keydown();\r\n                            if (keyactions.keypressed != undefined)\r\n                                keyactions.keypressed();\r\n                            break;\r\n                        case 2:\r\n                            if (keyactions.keyheld != undefined)\r\n                                keyactions.keyheld();\r\n                            if (keyactions.keypressed != undefined)\r\n                                keyactions.keypressed();\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        update() {\r\n            super.update();\r\n            this.updateKeys();\r\n        }\r\n    }\r\n    GameObjects.Player = Player;\r\n    class GameAnimations {\r\n    }\r\n    GameObjects.GameAnimations = GameAnimations;\r\n})(GameObjects || (GameObjects = {}));\r\n\n\n//# sourceURL=webpack:///../../engine/source/alacrity/_gameobjects.ts?\n}");

/***/ },

/***/ "../../engine/source/alacrity/_incarnations.ts"
/*!*****************************************************!*\
  !*** ../../engine/source/alacrity/_incarnations.ts ***!
  \*****************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Incarnations: () => (/* binding */ Incarnations)\n/* harmony export */ });\n/* harmony import */ var _bodies__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_bodies */ \"../../engine/source/alacrity/_bodies.ts\");\n/* harmony import */ var _type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_type */ \"../../engine/source/_type.ts\");\n\r\n\r\nvar Incarnations;\r\n(function (Incarnations) {\r\n    let Dir;\r\n    (function (Dir) {\r\n        Dir[Dir[\"up\"] = 0] = \"up\";\r\n        Dir[Dir[\"left\"] = 1] = \"left\";\r\n        Dir[Dir[\"down\"] = 2] = \"down\";\r\n        Dir[Dir[\"right\"] = 3] = \"right\";\r\n    })(Dir = Incarnations.Dir || (Incarnations.Dir = {}));\r\n    class Incarnated extends _bodies__WEBPACK_IMPORTED_MODULE_0__.Bodies.Mobility {\r\n        constructor() {\r\n            super(...arguments);\r\n            this.state = \"\";\r\n            this.anims = {};\r\n            this.dir = 2;\r\n        }\r\n        switchAnimation(state, direction = -1) {\r\n            let dir = direction == -1 ? this.dir : direction;\r\n            if (this.state == state) {\r\n                this.myFrame.frame = [this.anims[this.state][dir]];\r\n                return;\r\n            }\r\n            this.state = state;\r\n            this.myFrame.frame = [this.anims[this.state][dir]];\r\n            this.anims[this.state][dir].restart();\r\n        }\r\n    }\r\n    Incarnations.Incarnated = Incarnated;\r\n    class Fauna extends Incarnated {\r\n        update() {\r\n            super.update();\r\n            for (let a in this.actions) {\r\n                if (this.actions[a].state == _type__WEBPACK_IMPORTED_MODULE_1__.RunSwitch.off)\r\n                    continue;\r\n                if (this.actions[a].state == _type__WEBPACK_IMPORTED_MODULE_1__.RunSwitch.disabled) {\r\n                    if (this.actions[a].disabled != undefined)\r\n                        this.actions[a].disabled();\r\n                    this.actions[a].state = _type__WEBPACK_IMPORTED_MODULE_1__.RunSwitch.off;\r\n                }\r\n                else if (this.actions[a].state == _type__WEBPACK_IMPORTED_MODULE_1__.RunSwitch.enabled) {\r\n                    if (this.actions[a].enabled != undefined)\r\n                        this.actions[a].enabled();\r\n                    if (this.actions[a].running != undefined)\r\n                        this.actions[a].running();\r\n                    this.actions[a].state = _type__WEBPACK_IMPORTED_MODULE_1__.RunSwitch.running;\r\n                }\r\n                else if (this.actions[a].timer?.test().state == 'triggered') {\r\n                    if (this.actions[a].elapsed != undefined)\r\n                        this.actions[a].elapsed();\r\n                }\r\n                else if (this.actions[a].state == _type__WEBPACK_IMPORTED_MODULE_1__.RunSwitch.running) {\r\n                    if (this.actions[a].running != undefined)\r\n                        this.actions[a].running();\r\n                }\r\n            }\r\n        }\r\n        switchAction(action) {\r\n            this.actions[action].timer?.restart();\r\n            this.actions[action].state = _type__WEBPACK_IMPORTED_MODULE_1__.RunSwitch.enabled;\r\n            if (action == this.action)\r\n                return;\r\n            this.actions[this.action].state = _type__WEBPACK_IMPORTED_MODULE_1__.RunSwitch.disabled;\r\n            this.action = action;\r\n        }\r\n    }\r\n    Incarnations.Fauna = Fauna;\r\n    // export abstract class Player extends Fauna {\r\n    //   // protected allstates = (1<<AniSt.count) - 1;\r\n    //     public hp : Health = {max:3,current:3};\r\n    //     public myCamera  : Camera;\r\n    //   }\r\n})(Incarnations || (Incarnations = {}));\r\n\n\n//# sourceURL=webpack:///../../engine/source/alacrity/_incarnations.ts?\n}");

/***/ },

/***/ "../../engine/source/alacrity/time.ts"
/*!********************************************!*\
  !*** ../../engine/source/alacrity/time.ts ***!
  \********************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Time: () => (/* binding */ Time)\n/* harmony export */ });\nvar Time;\r\n(function (Time) {\r\n    class Watch {\r\n    }\r\n    Watch.lastTick = 0;\r\n    Watch.currTick = Date.now();\r\n    class Delta {\r\n        static refresh() {\r\n            Watch.currTick = Date.now();\r\n            Delta.delta = Math.min(Watch.currTick - Watch.lastTick, 100);\r\n            Watch.lastTick = Watch.currTick;\r\n        }\r\n        static getTick() {\r\n            return Watch.currTick;\r\n        }\r\n    }\r\n    Delta.delta = 16;\r\n    Time.Delta = Delta;\r\n    class Timeout {\r\n        constructor(ms, triggerName, params = { continuous: false, repeat: true }, actions = {}) {\r\n            this.step = 0;\r\n            this.deletion = false;\r\n            this.paused = false;\r\n            this.done = false;\r\n            this.continuous = false;\r\n            this.repeat = true;\r\n            this.pauseTime = 0;\r\n            this.actions = {};\r\n            this.ms = ms;\r\n            this.trigName = triggerName;\r\n            if (params.continuous)\r\n                this.continuous = params.continuous;\r\n            else\r\n                this.continuous = false;\r\n            if (params.repeat)\r\n                this.repeat = params.repeat;\r\n            else\r\n                this.repeat = true;\r\n            this.start = Watch.currTick;\r\n            if (ms[0] === Infinity)\r\n                this.end = Infinity;\r\n            else\r\n                this.end = Watch.currTick + ms[0];\r\n            this.actions = actions;\r\n        }\r\n        reset() {\r\n            this.start = Watch.currTick;\r\n            if (this.ms[this.step] === Infinity)\r\n                this.end = Infinity;\r\n            else\r\n                this.end = Watch.currTick + this.ms[this.step];\r\n        }\r\n        restart() {\r\n            this.paused = false;\r\n            this.step = 0;\r\n            this.reset();\r\n        }\r\n        pause() {\r\n            this.pauseTime = Watch.currTick;\r\n            this.paused = true;\r\n        }\r\n        resume() {\r\n            this.start += Watch.currTick - this.pauseTime;\r\n            if (this.end === Infinity) { }\r\n            else\r\n                this.end += Watch.currTick - this.pauseTime;\r\n            this.pauseTime = 0;\r\n            this.paused = false;\r\n        }\r\n        getTimeoutTicks() {\r\n            return (this.paused ? this.pauseTime : Watch.currTick) - this.start;\r\n        }\r\n        test() {\r\n            if (this.done)\r\n                return { name: this.trigName, state: \"done\" };\r\n            if (!this.paused) {\r\n                if (this.end <= Watch.currTick) {\r\n                    if (this.continuous)\r\n                        this.step++;\r\n                    else if (!this.repeat)\r\n                        this.done = true;\r\n                    if (this.step >= this.ms.length) {\r\n                        this.step = 0;\r\n                        if (!this.repeat)\r\n                            this.done = true;\r\n                    }\r\n                    this.start = Watch.currTick;\r\n                    if (this.ms[this.step] !== Infinity)\r\n                        this.end = Watch.currTick + this.ms[this.step];\r\n                    else\r\n                        this.end = Infinity;\r\n                    if (this.actions.triggered)\r\n                        this.actions.triggered(this);\r\n                    return { name: this.trigName, state: \"triggered\" };\r\n                }\r\n                if (this.actions.active)\r\n                    this.actions.active(this);\r\n                else\r\n                    return { name: this.trigName, state: \"active\" };\r\n            }\r\n            if (this.end === Infinity) { }\r\n            else\r\n                this.end += Delta.delta;\r\n            return { name: this.trigName, state: \"paused\" };\r\n        }\r\n    }\r\n    Time.Timeout = Timeout;\r\n})(Time || (Time = {}));\r\n\n\n//# sourceURL=webpack:///../../engine/source/alacrity/time.ts?\n}");

/***/ },

/***/ "../../engine/source/debug/dbggrid.ts"
/*!********************************************!*\
  !*** ../../engine/source/debug/dbggrid.ts ***!
  \********************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Debug: () => (/* binding */ Debug)\n/* harmony export */ });\n/* harmony import */ var _render_composite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../render/composite */ \"../../engine/source/render/composite.ts\");\n\r\nvar Debug;\r\n(function (Debug) {\r\n    class Grid {\r\n        static see(grid, where) {\r\n            let imgs = [];\r\n            let square = 16;\r\n            console.log(\"Grid resolution\");\r\n            for (let y = where.y; y < where.h; y += grid.resolution) {\r\n                for (let x = where.x; x < where.w; x += grid.resolution) {\r\n                    if (grid.testWall({ x: x, y: y }))\r\n                        imgs.push(new _render_composite__WEBPACK_IMPORTED_MODULE_0__.Composite.Image(\"_assets/_debug/blocking.png\", { x: 0, y: 0, w: 16, h: 16 }, { x: x, y: y, w: 16, h: 16 }));\r\n                }\r\n            }\r\n            let snp = new _render_composite__WEBPACK_IMPORTED_MODULE_0__.Composite.Snap(imgs);\r\n            console.log(\"Grid created\", snp);\r\n            snp.rprops.layer = 10;\r\n            return snp;\r\n        }\r\n    }\r\n    Debug.Grid = Grid;\r\n})(Debug || (Debug = {}));\r\n\n\n//# sourceURL=webpack:///../../engine/source/debug/dbggrid.ts?\n}");

/***/ },

/***/ "../../engine/source/engine.ts"
/*!*************************************!*\
  !*** ../../engine/source/engine.ts ***!
  \*************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Engine: () => (/* binding */ Engine)\n/* harmony export */ });\n/* harmony import */ var _render_assets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./render/assets */ \"../../engine/source/render/assets.ts\");\n/* harmony import */ var _systems_keyboard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./systems/keyboard */ \"../../engine/source/systems/keyboard.ts\");\n/* harmony import */ var _alacrity_time__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./alacrity/time */ \"../../engine/source/alacrity/time.ts\");\n\r\n\r\n\r\nclass Engine {\r\n    constructor(game) {\r\n    }\r\n    static async start(game) {\r\n        _render_assets__WEBPACK_IMPORTED_MODULE_0__.Assets.initAudio();\r\n        await game.load();\r\n        return;\r\n    }\r\n}\r\nEngine.paused = true;\r\nEngine.games = [];\r\nEngine.sharedobjects = [];\r\nEngine.mainLoop = () => {\r\n    _alacrity_time__WEBPACK_IMPORTED_MODULE_2__.Time.Delta.refresh();\r\n    Engine.games.forEach((g) => {\r\n        g.run(Engine.sharedobjects);\r\n        g.window.update();\r\n    });\r\n    _systems_keyboard__WEBPACK_IMPORTED_MODULE_1__.Keyboard.refresh(); // this is after engine.game.run because the keys are asynchronously updated to keydown and keyup, so keyheld is the only thing to update\r\n    requestAnimationFrame(Engine.mainLoop);\r\n};\r\n\n\n//# sourceURL=webpack:///../../engine/source/engine.ts?\n}");

/***/ },

/***/ "../../engine/source/index.ts"
/*!************************************!*\
  !*** ../../engine/source/index.ts ***!
  \************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Assets: () => (/* reexport safe */ _render_assets__WEBPACK_IMPORTED_MODULE_12__.Assets),\n/* harmony export */   Bodies: () => (/* reexport safe */ _alacrity_bodies__WEBPACK_IMPORTED_MODULE_0__.Bodies),\n/* harmony export */   C: () => (/* reexport module object */ _physics_states__WEBPACK_IMPORTED_MODULE_7__),\n/* harmony export */   Capture: () => (/* reexport safe */ _physics_capture__WEBPACK_IMPORTED_MODULE_14__.Capture),\n/* harmony export */   CollisionGrid: () => (/* reexport safe */ _physics_gridCollision__WEBPACK_IMPORTED_MODULE_17__.CollisionGrid),\n/* harmony export */   Composite: () => (/* reexport safe */ _render_composite__WEBPACK_IMPORTED_MODULE_4__.Composite),\n/* harmony export */   Debug: () => (/* reexport safe */ _debug_dbggrid__WEBPACK_IMPORTED_MODULE_23__.Debug),\n/* harmony export */   Engine: () => (/* reexport safe */ _engine__WEBPACK_IMPORTED_MODULE_21__.Engine),\n/* harmony export */   GameObjects: () => (/* reexport safe */ _alacrity_gameobjects__WEBPACK_IMPORTED_MODULE_22__.GameObjects),\n/* harmony export */   Games: () => (/* reexport safe */ _games__WEBPACK_IMPORTED_MODULE_2__.Games),\n/* harmony export */   GaniParser: () => (/* reexport safe */ _parsers_ganiParser__WEBPACK_IMPORTED_MODULE_13__.GaniParser),\n/* harmony export */   Incarnations: () => (/* reexport safe */ _alacrity_incarnations__WEBPACK_IMPORTED_MODULE_3__.Incarnations),\n/* harmony export */   IniParser: () => (/* reexport safe */ _parsers_iniparser__WEBPACK_IMPORTED_MODULE_16__.IniParser),\n/* harmony export */   Keyboard: () => (/* reexport safe */ _systems_keyboard__WEBPACK_IMPORTED_MODULE_8__.Keyboard),\n/* harmony export */   NPCCollision: () => (/* reexport safe */ _physics_npcCollision__WEBPACK_IMPORTED_MODULE_11__.NPCCollision),\n/* harmony export */   Normal: () => (/* reexport safe */ _render_shaders_normal__WEBPACK_IMPORTED_MODULE_25__.Normal),\n/* harmony export */   Physics: () => (/* reexport safe */ _systems_physics__WEBPACK_IMPORTED_MODULE_9__.Physics),\n/* harmony export */   Render: () => (/* reexport safe */ _render_render__WEBPACK_IMPORTED_MODULE_5__.Render),\n/* harmony export */   Reverser: () => (/* reexport safe */ _render_shaders_reverser__WEBPACK_IMPORTED_MODULE_26__.Reverser),\n/* harmony export */   ShaderLoader: () => (/* reexport safe */ _render_shaderloader__WEBPACK_IMPORTED_MODULE_19__.ShaderLoader),\n/* harmony export */   System: () => (/* reexport safe */ _systems_system__WEBPACK_IMPORTED_MODULE_15__.System),\n/* harmony export */   T: () => (/* reexport module object */ _type__WEBPACK_IMPORTED_MODULE_6__),\n/* harmony export */   Tiled: () => (/* reexport safe */ _parsers_tiledParser__WEBPACK_IMPORTED_MODULE_18__.Tiled),\n/* harmony export */   Time: () => (/* reexport safe */ _alacrity_time__WEBPACK_IMPORTED_MODULE_1__.Time),\n/* harmony export */   Touch: () => (/* reexport safe */ _systems_touch__WEBPACK_IMPORTED_MODULE_20__.Touch),\n/* harmony export */   WhiteTransparent: () => (/* reexport safe */ _render_shaders_whitetransparent__WEBPACK_IMPORTED_MODULE_24__.WhiteTransparent),\n/* harmony export */   Window: () => (/* reexport safe */ _systems_window__WEBPACK_IMPORTED_MODULE_10__.Window)\n/* harmony export */ });\n/* harmony import */ var _alacrity_bodies__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./alacrity/_bodies */ \"../../engine/source/alacrity/_bodies.ts\");\n/* harmony import */ var _alacrity_time__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./alacrity/time */ \"../../engine/source/alacrity/time.ts\");\n/* harmony import */ var _games__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_games */ \"../../engine/source/_games.ts\");\n/* harmony import */ var _alacrity_incarnations__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./alacrity/_incarnations */ \"../../engine/source/alacrity/_incarnations.ts\");\n/* harmony import */ var _render_composite__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./render/composite */ \"../../engine/source/render/composite.ts\");\n/* harmony import */ var _render_render__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./render/_render */ \"../../engine/source/render/_render.ts\");\n/* harmony import */ var _type__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_type */ \"../../engine/source/_type.ts\");\n/* harmony import */ var _physics_states__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./physics/states */ \"../../engine/source/physics/states.ts\");\n/* harmony import */ var _systems_keyboard__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./systems/keyboard */ \"../../engine/source/systems/keyboard.ts\");\n/* harmony import */ var _systems_physics__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./systems/physics */ \"../../engine/source/systems/physics.ts\");\n/* harmony import */ var _systems_window__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./systems/window */ \"../../engine/source/systems/window.ts\");\n/* harmony import */ var _physics_npcCollision__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./physics/npcCollision */ \"../../engine/source/physics/npcCollision.ts\");\n/* harmony import */ var _render_assets__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./render/assets */ \"../../engine/source/render/assets.ts\");\n/* harmony import */ var _parsers_ganiParser__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./parsers/ganiParser */ \"../../engine/source/parsers/ganiParser.ts\");\n/* harmony import */ var _physics_capture__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./physics/capture */ \"../../engine/source/physics/capture.ts\");\n/* harmony import */ var _systems_system__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./systems/_system */ \"../../engine/source/systems/_system.ts\");\n/* harmony import */ var _parsers_iniparser__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./parsers/iniparser */ \"../../engine/source/parsers/iniparser.ts\");\n/* harmony import */ var _physics_gridCollision__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./physics/gridCollision */ \"../../engine/source/physics/gridCollision.ts\");\n/* harmony import */ var _parsers_tiledParser__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./parsers/tiledParser */ \"../../engine/source/parsers/tiledParser.ts\");\n/* harmony import */ var _render_shaderloader__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./render/shaderloader */ \"../../engine/source/render/shaderloader.ts\");\n/* harmony import */ var _systems_touch__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./systems/touch */ \"../../engine/source/systems/touch.ts\");\n/* harmony import */ var _engine__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./engine */ \"../../engine/source/engine.ts\");\n/* harmony import */ var _alacrity_gameobjects__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./alacrity/_gameobjects */ \"../../engine/source/alacrity/_gameobjects.ts\");\n/* harmony import */ var _debug_dbggrid__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./debug/dbggrid */ \"../../engine/source/debug/dbggrid.ts\");\n/* harmony import */ var _render_shaders_whitetransparent__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./render/shaders/whitetransparent */ \"../../engine/source/render/shaders/whitetransparent.ts\");\n/* harmony import */ var _render_shaders_normal__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./render/shaders/normal */ \"../../engine/source/render/shaders/normal.ts\");\n/* harmony import */ var _render_shaders_reverser__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./render/shaders/reverser */ \"../../engine/source/render/shaders/reverser.ts\");\n// import WhiteTransparent from '../../_backups/20250912/src/engine/render/shaders/whitetransparent';\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n //Keyboard\r\n //Physics\r\n //Window\r\n //NPCCollision\r\n //Assets\r\n //GaniParser\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack:///../../engine/source/index.ts?\n}");

/***/ },

/***/ "../../engine/source/parsers/ganiParser.ts"
/*!*************************************************!*\
  !*** ../../engine/source/parsers/ganiParser.ts ***!
  \*************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GaniParser: () => (/* binding */ GaniParser)\n/* harmony export */ });\nclass GaniParser {\r\n    // private \r\n    static parse(file) {\r\n        let sprites = [];\r\n        let properties = 0;\r\n        let next = \"\";\r\n        let anims = [];\r\n        for (let i = 0; i < 4; i++) {\r\n            anims.push({\r\n                frames: []\r\n            });\r\n        }\r\n        // let anims: Array<Composite.Animation> = [new Composite.Animation([]),new Composite.Animation([]),new Composite.Animation([]),new Composite.Animation([])]\r\n        // let anims: Array<Array<Composite.Snap>>= [[]]\r\n        // let gani: Gani = {\r\n        //   properties : 0,\r\n        //   // sprites : [],\r\n        //   next: \"\",\r\n        //   animations: \r\n        // };\r\n        let ani = false;\r\n        let defaults = {\r\n            HEAD: \"\",\r\n            BODY: \"\",\r\n            SWORD: \"redlightsabersword.png\"\r\n        };\r\n        let lines = file.split('\\n').map((l) => l.trim());\r\n        for (let i = 0; i < lines.length; i++) {\r\n            let properties = lines[i].split(' ');\r\n            let firstargument = properties.shift();\r\n            switch (firstargument) {\r\n                case \"DEFAULTHEAD\":\r\n                    defaults.HEAD = properties.join(' ');\r\n                    break;\r\n                case \"DEFAULTBODY\":\r\n                    defaults.BODY = properties.join(' ');\r\n            }\r\n        }\r\n        let direction = 0;\r\n        for (let i = 0; i < lines.length; i++) {\r\n            if (ani) {\r\n                if (lines[i].startsWith(\"ANIEND\"))\r\n                    break;\r\n                if (lines[i].startsWith(\"PLAYSOUND\"))\r\n                    continue;\r\n                let timeout = 300;\r\n                if (lines[i].startsWith(\"WAIT\")) {\r\n                    timeout = Number(lines[i].split(' ')[1]) * 1000;\r\n                    continue;\r\n                }\r\n                let imgs = lines[i].split(',').filter((l) => l != '');\r\n                if (imgs.length > 0) {\r\n                    // let snap: Composite.Snap = new Composite.Snap([]);\r\n                    let parts = [];\r\n                    for (let j = 0; j < imgs.length; j++) {\r\n                        let attributes = imgs[j].split(' ').filter((l) => l != '');\r\n                        // console.log(attributes)\r\n                        if (sprites[Number(attributes[0])].file === \"\")\r\n                            continue;\r\n                        // snap.parts.push(\r\n                        //   new Composite.Image(\r\n                        //     sprites[Number(attributes[0])].file, \r\n                        //     sprites[Number(attributes[0])].srcrect, \r\n                        //     { x:Number(attributes[1]), y: Number(attributes[2]),\r\n                        //       w:sprites[Number(attributes[0])].srcrect.w,\r\n                        //       h:sprites[Number(attributes[0])].srcrect.h,\r\n                        // }));\r\n                        parts.push({\r\n                            file: sprites[Number(attributes[0])].file,\r\n                            srcrect: sprites[Number(attributes[0])].srcrect,\r\n                            dstrect: {\r\n                                x: Number(attributes[1]),\r\n                                y: Number(attributes[2]),\r\n                                w: sprites[Number(attributes[0])].srcrect.w,\r\n                                h: sprites[Number(attributes[0])].srcrect.h,\r\n                            }\r\n                        });\r\n                    }\r\n                    // snap.parts = snap.parts.filter()\r\n                    // anims[direction].frames.push(snap);\r\n                    anims[direction].frames.push(parts);\r\n                    direction = (direction + 1) % 4;\r\n                }\r\n            }\r\n            else {\r\n                let properties = lines[i].split(' ').filter((l) => l != '');\r\n                // console.log(properties)\r\n                let firstargument = properties.shift();\r\n                switch (firstargument) {\r\n                    case \"SPRITE\":\r\n                        sprites[Number(properties[0])] = {\r\n                            file: defaults[properties[1]] == undefined ? \"\" : \"_assets/arbre/\" + defaults[properties[1]],\r\n                            srcrect: { x: Number(properties[2]), y: Number(properties[3]), w: Number(properties[4]), h: Number(properties[5]) }\r\n                        };\r\n                        // console.log( sprites[Number(properties[0])]);\r\n                        break;\r\n                    case \"ATTACHSPRITE\":\r\n                        break;\r\n                    case \"ANI\":\r\n                        ani = true;\r\n                        break;\r\n                    case \"LOOP\":\r\n                        // properties |= GaniProperties.LOOP;\r\n                        break;\r\n                    case \"CONTINUOUS\":\r\n                        // properties |= GaniProperties.CONTINUOUS;\r\n                        break;\r\n                    case \"SETBACKTO\":\r\n                        next = properties.join(' ');\r\n                        break;\r\n                    case \"SINGLEDIRECTION\":\r\n                        // properties |= GaniProperties.SINGLEDIRECTION;\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n        console.log(anims);\r\n        return {\r\n            properties: properties,\r\n            next: next,\r\n            animations: anims\r\n        };\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///../../engine/source/parsers/ganiParser.ts?\n}");

/***/ },

/***/ "../../engine/source/parsers/iniparser.ts"
/*!************************************************!*\
  !*** ../../engine/source/parsers/iniparser.ts ***!
  \************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IniParser: () => (/* binding */ IniParser)\n/* harmony export */ });\n/* harmony import */ var _render_assets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../render/assets */ \"../../engine/source/render/assets.ts\");\n\r\nclass IniParser {\r\n    static loadCSV(file) {\r\n        return { tileYX: file.split('\\n').filter((a) => a != '').map(x => x.split(',').map(y => Number(y))) };\r\n    }\r\n    static async loadIni(iniFileName) {\r\n        let tiles = [];\r\n        let npcs = \"\";\r\n        let collisions = [];\r\n        let tileset;\r\n        let tilesetwidth;\r\n        let square = { w: 16, h: 16 };\r\n        let playLayer;\r\n        let file = \"\";\r\n        const inifile = _render_assets__WEBPACK_IMPORTED_MODULE_0__.Assets.getText(await _render_assets__WEBPACK_IMPORTED_MODULE_0__.Assets.addText(iniFileName));\r\n        const iniLines = inifile.split('\\n');\r\n        for (let i = 0; i < iniLines.length; i++) {\r\n            const currLine = iniLines[i].split(' ');\r\n            switch (currLine[0]) {\r\n                case \"TILESET\":\r\n                    const currParams = currLine[1].split(':');\r\n                    switch (currParams[0]) {\r\n                        case \"SQUARE\":\r\n                            square = { w: Number(currParams[1]), h: Number(currParams[1]) };\r\n                            break;\r\n                        case \"FILE\":\r\n                            tileset = await _render_assets__WEBPACK_IMPORTED_MODULE_0__.Assets.addImage(currParams[1]);\r\n                            file = currParams[1];\r\n                            break;\r\n                    }\r\n                    ;\r\n                    break;\r\n                case \"PLAYGROUND\":\r\n                    playLayer = Number(currLine[1]);\r\n                    break;\r\n                case \"CSV\":\r\n                    let props = currLine[1].split(':');\r\n                    const tileLayer = _render_assets__WEBPACK_IMPORTED_MODULE_0__.Assets.getText(await _render_assets__WEBPACK_IMPORTED_MODULE_0__.Assets.addText(props[1]));\r\n                    tiles[Number(props[0])] = { tileYX: tileLayer.split('\\n').filter((a) => a != '').map(x => x.split(',').map(y => Number(y))) };\r\n                    break;\r\n                case \"NPCS\":\r\n                    let npcsInfo = _render_assets__WEBPACK_IMPORTED_MODULE_0__.Assets.getText(await _render_assets__WEBPACK_IMPORTED_MODULE_0__.Assets.addText(currLine[1]));\r\n                    npcs = npcsInfo /* .replace(/\\n(?!\\Z)/g,',').split(',') */;\r\n                    break;\r\n                case \"COLLISION\":\r\n                    const collisionLn = _render_assets__WEBPACK_IMPORTED_MODULE_0__.Assets.getText(await _render_assets__WEBPACK_IMPORTED_MODULE_0__.Assets.addText(currLine[1]));\r\n                    const ln = collisionLn.trim().split('\\n');\r\n                    let coll = [];\r\n                    for (let l of ln) {\r\n                        coll.push(l.split(',').map((y) => Number(y) < 0 ? false : true));\r\n                    }\r\n                    collisions.push(coll);\r\n                    console.log(collisions);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n            ;\r\n        }\r\n        tilesetwidth = _render_assets__WEBPACK_IMPORTED_MODULE_0__.Assets.getTextureWidth(file) - (_render_assets__WEBPACK_IMPORTED_MODULE_0__.Assets.getTextureWidth(file) % square.w);\r\n        return {\r\n            tiles: tiles,\r\n            npcs: npcs,\r\n            collisions: collisions,\r\n            tileset: tileset,\r\n            tilesetwidth: tilesetwidth,\r\n            square: square,\r\n            playLayer: playLayer,\r\n            grid: { w: tiles[0].tileYX[0].length, h: tiles[0].tileYX.length }\r\n        };\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///../../engine/source/parsers/iniparser.ts?\n}");

/***/ },

/***/ "../../engine/source/parsers/tiledParser.ts"
/*!**************************************************!*\
  !*** ../../engine/source/parsers/tiledParser.ts ***!
  \**************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tiled: () => (/* binding */ Tiled)\n/* harmony export */ });\n/* harmony import */ var _render_composite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../render/composite */ \"../../engine/source/render/composite.ts\");\n/* harmony import */ var _render_textures__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../render/textures */ \"../../engine/source/render/textures.ts\");\n\r\n\r\nclass Tiled {\r\n    static blit(glContext, shadercontext, cellbuild, prefix) {\r\n        let i = -1;\r\n        return cellbuild.tiles.map(layer => {\r\n            i++;\r\n            console.log(layer);\r\n            const framebuffer = glContext.gl.createFramebuffer();\r\n            glContext.gl.bindFramebuffer(glContext.gl.FRAMEBUFFER, glContext.framebuffer);\r\n            const cellWidth = cellbuild.square.w * layer.tileYX[0].length;\r\n            const cellHeight = cellbuild.square.h * layer.tileYX.length;\r\n            const tilesperrow = (cellbuild.tilesetwidth / cellbuild.square.w);\r\n            let cellTex = _render_textures__WEBPACK_IMPORTED_MODULE_1__[\"default\"].createTexToBlitOn(glContext, cellWidth, cellHeight);\r\n            glContext.gl.framebufferTexture2D(glContext.gl.FRAMEBUFFER, glContext.gl.COLOR_ATTACHMENT0, glContext.gl.TEXTURE_2D, cellbuild.texture, 0);\r\n            glContext.gl.bindTexture(glContext.gl.TEXTURE_2D, cellTex);\r\n            for (let y = 0; y < layer.tileYX.length; y++) {\r\n                for (let x = 0; x < layer.tileYX[y].length; x++) {\r\n                    glContext.gl.copyTexSubImage2D(glContext.gl.TEXTURE_2D, 0, x * cellbuild.square.w, y * cellbuild.square.h, \r\n                    // 0,\r\n                    layer.tileYX[y][x] % tilesperrow * cellbuild.square.w, Math.floor(layer.tileYX[y][x] / tilesperrow) * cellbuild.square.h, cellbuild.square.w, cellbuild.square.h);\r\n                }\r\n            }\r\n            glContext.addTexture(prefix + i, cellTex);\r\n            let a = new _render_composite__WEBPACK_IMPORTED_MODULE_0__.Composite.Image(glContext, shadercontext, prefix + i, { x: 0, y: 0, w: cellWidth, h: cellHeight }, { x: 0, y: 0, w: cellWidth, h: cellHeight });\r\n            let b = new _render_composite__WEBPACK_IMPORTED_MODULE_0__.Composite.Snap(glContext, shadercontext, [a]);\r\n            b.rprops.layer = i - cellbuild.playLayer;\r\n            return b;\r\n        });\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///../../engine/source/parsers/tiledParser.ts?\n}");

/***/ },

/***/ "../../engine/source/physics/_collision.ts"
/*!*************************************************!*\
  !*** ../../engine/source/physics/_collision.ts ***!
  \*************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Collision)\n/* harmony export */ });\nclass Collision {\r\n    constructor(from, cwith, type) {\r\n        this.deleteMe = false;\r\n        // public offY   : number;\r\n        // public offX   : number;\r\n        // public width  : number;\r\n        // public height : number;\r\n        // public ogBounds : T.Bounds = {x:0, y:0, w:0,h:0};\r\n        this.padding = { x: 1, y: 1 };\r\n        this.from = from;\r\n        this.cwith = cwith;\r\n        this.type = type;\r\n    }\r\n    update(to) {\r\n        for (let e of to) {\r\n            this.intersect(e);\r\n        }\r\n    }\r\n    static inBounds(x, y, bounds) {\r\n        return x > bounds.x &&\r\n            x < bounds.x + bounds.w &&\r\n            y > bounds.y &&\r\n            y < bounds.y + bounds.h;\r\n    }\r\n    computeCollidePoints(bd, padding = { x: 1, y: 1 }, res = { w: 1, h: 1 }, bitcount = 0) {\r\n        let cornerindices = [[\r\n                /* [0][0] */ Math.max(0, Math.floor((bd.x + padding.x * 2) / res.w)) >>> bitcount,\r\n                /* [0][1] */ Math.max(0, Math.floor((bd.x) / res.w)) >>> bitcount,\r\n                /* [0][2] */ Math.max(0, Math.floor((bd.x + bd.w - padding.x * 2) / res.w)) >>> bitcount,\r\n                /* [0][3] */ Math.max(0, Math.floor((bd.x + bd.w) / res.w)) >>> bitcount\r\n            ], [\r\n                /* [1][0] */ Math.max(0, Math.floor((bd.y + padding.y * 2) / res.h)),\r\n                /* [1][1] */ Math.max(0, Math.floor((bd.y) / res.h)),\r\n                /* [1][2] */ Math.max(0, Math.floor((bd.y + bd.h - padding.y * 2) / res.h)),\r\n                /* [1][3] */ Math.max(0, Math.floor((bd.y + bd.h) / res.h))\r\n            ]];\r\n        // [dir][xy][pt#]\r\n        return [\r\n            [[cornerindices[0][0], cornerindices[0][2]], [cornerindices[1][1], cornerindices[1][1]]],\r\n            [[cornerindices[0][1], cornerindices[0][1]], [cornerindices[1][0], cornerindices[1][2]]],\r\n            [[cornerindices[0][0], cornerindices[0][2]], [cornerindices[1][3], cornerindices[1][3]]],\r\n            [[cornerindices[0][3], cornerindices[0][3]], [cornerindices[1][0], cornerindices[1][2]]]\r\n        ];\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///../../engine/source/physics/_collision.ts?\n}");

/***/ },

/***/ "../../engine/source/physics/capture.ts"
/*!**********************************************!*\
  !*** ../../engine/source/physics/capture.ts ***!
  \**********************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Capture: () => (/* binding */ Capture)\n/* harmony export */ });\n/* harmony import */ var _collision__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_collision */ \"../../engine/source/physics/_collision.ts\");\n/* harmony import */ var _states__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./states */ \"../../engine/source/physics/states.ts\");\n\r\n\r\nclass Capture extends _collision__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n    constructor(collideswith, type, owner, hitbox, oncollision) {\r\n        super(_states__WEBPACK_IMPORTED_MODULE_1__.CollideLayers.none, collideswith, type);\r\n        this.owner = owner;\r\n        this.hitbox = hitbox;\r\n        this.oncollision = oncollision;\r\n        owner.collisions.push(this);\r\n    }\r\n    intersect(bd) {\r\n        let rectA = { x: this.owner.pos.x + this.hitbox.x, y: this.owner.pos.y + this.hitbox.y, w: this.hitbox.w, h: this.hitbox.h };\r\n        let rectB = { x: bd.pos.x + bd.hitbox.x, y: bd.pos.y + bd.hitbox.y, w: bd.hitbox.w, h: bd.hitbox.h };\r\n        // overlap\r\n        if ((rectA.x < rectB.x + rectB.w && rectA.x + rectA.w > rectB.x && rectA.y < rectB.y + rectB.h && rectA.y + rectA.h > rectB.y)) {\r\n            if (this.deleteMe == false)\r\n                this.deleteMe = this.oncollision(this.owner, bd);\r\n            // el\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///../../engine/source/physics/capture.ts?\n}");

/***/ },

/***/ "../../engine/source/physics/gridCollision.ts"
/*!****************************************************!*\
  !*** ../../engine/source/physics/gridCollision.ts ***!
  \****************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CollisionGrid: () => (/* binding */ CollisionGrid)\n/* harmony export */ });\n/* harmony import */ var _states__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./states */ \"../../engine/source/physics/states.ts\");\n/* harmony import */ var _collision__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_collision */ \"../../engine/source/physics/_collision.ts\");\nvar _a;\r\n\r\n\r\nclass CollisionGrid extends _collision__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\r\n    constructor(boolArr, resolution, collideswith, type) {\r\n        super(_states__WEBPACK_IMPORTED_MODULE_0__.CollideLayers.grid, collideswith, type);\r\n        // private padding : T.Point = {x:2,y:2};\r\n        this.resolution = 16;\r\n        this.walls = []; // walls[y][x]\r\n        this.ylimit = boolArr.length;\r\n        let gridwidth = boolArr[0].length;\r\n        this.xlimit = Math.ceil(boolArr[0].length / CollisionGrid.chunksize);\r\n        let flatArr = boolArr.flat(Infinity);\r\n        let passes = 0;\r\n        this.resolution = resolution;\r\n        for (let idx = 0; idx < flatArr.length; idx += gridwidth) {\r\n            this.walls.push(Array());\r\n            for (let i = 0; i < gridwidth; i += CollisionGrid.chunksize) {\r\n                let stuff = 0;\r\n                for (let bAidx = 0; bAidx < CollisionGrid.chunksize; bAidx++) {\r\n                    if (i + bAidx >= gridwidth)\r\n                        break;\r\n                    if (flatArr[idx + i + bAidx] == true) {\r\n                        stuff |= 1 << bAidx;\r\n                    }\r\n                }\r\n                this.walls[passes].push(stuff);\r\n            }\r\n            passes += 1;\r\n        }\r\n    }\r\n    //gXbd and gYbd are in grid coordinates\r\n    againstGrid(gXbd, gYbd, bdX) {\r\n        let xIndex = gXbd;\r\n        let yIndex = gYbd;\r\n        if (yIndex >= this.ylimit || yIndex < 0)\r\n            return false;\r\n        const bitX = Math.floor(((bdX) / this.resolution)) % (CollisionGrid.chunksize); //CollisionGrid.sizeBit;\r\n        let bShift = bitX;\r\n        let checkX = 1 << bShift;\r\n        if (xIndex >= this.xlimit || xIndex < 0)\r\n            return false;\r\n        return ((this.walls[yIndex][xIndex] & checkX) != 0);\r\n    }\r\n    testWall(point) {\r\n        return this.againstGrid(Math.floor(point.x / this.resolution) >>> CollisionGrid.bitcount, Math.floor(point.y / this.resolution), point.x);\r\n    }\r\n    /**\r\n     *\r\n     * @param arch\r\n     * @returns 0 up to 3 right boolean array of if a wall is nearby in each direction\r\n     */\r\n    intersect(bd) {\r\n        const collidePoints = this.computeCollidePoints({ x: bd.pos.x + bd.hitbox.x, y: bd.pos.y + bd.hitbox.y, w: bd.hitbox.w, h: bd.hitbox.h }, this.padding, { w: this.resolution, h: this.resolution }, CollisionGrid.bitcount);\r\n        //check top\r\n        this.checkCollisionDirection(bd, 0, collidePoints[0][0][0], collidePoints[0][1][0], bd.pos.x + bd.hitbox.x + 2 * this.padding.x, collidePoints[0][0][1], collidePoints[0][1][1], bd.pos.x + bd.hitbox.x + bd.hitbox.w - 2 * this.padding.x);\r\n        //check left\r\n        this.checkCollisionDirection(bd, 1, collidePoints[1][0][0], collidePoints[1][1][0], bd.pos.x + bd.hitbox.x, collidePoints[1][0][1], collidePoints[1][1][1], bd.pos.x + bd.hitbox.x);\r\n        //check below\r\n        this.checkCollisionDirection(bd, 2, collidePoints[2][0][0], collidePoints[2][1][0], bd.pos.x + bd.hitbox.x + 2 * this.padding.x, collidePoints[2][0][1], collidePoints[2][1][1], bd.pos.x + bd.hitbox.x + bd.hitbox.w - 2 * this.padding.x);\r\n        //check right\r\n        this.checkCollisionDirection(bd, 3, collidePoints[3][0][0], collidePoints[3][1][0], bd.pos.x + bd.hitbox.x + bd.hitbox.w - this.padding.x, collidePoints[3][0][1], collidePoints[3][1][1], bd.pos.x + bd.hitbox.x + bd.hitbox.w - this.padding.x);\r\n    }\r\n    checkCollisionDirection(bd, direction, x1, y1, posX1, x2, y2, posX2) {\r\n        const collision1 = this.againstGrid(x1, y1, posX1);\r\n        const collision2 = this.againstGrid(x2, y2, posX2);\r\n        bd.activeeffects[direction] |=\r\n            collision1 || collision2\r\n                ? this.type\r\n                : _states__WEBPACK_IMPORTED_MODULE_0__.CollideTypes.none;\r\n    }\r\n}\r\n_a = CollisionGrid;\r\nCollisionGrid.bitcount = 5; //32 bit\r\nCollisionGrid.chunksize = 1 << _a.bitcount;\r\n\n\n//# sourceURL=webpack:///../../engine/source/physics/gridCollision.ts?\n}");

/***/ },

/***/ "../../engine/source/physics/npcCollision.ts"
/*!***************************************************!*\
  !*** ../../engine/source/physics/npcCollision.ts ***!
  \***************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NPCCollision: () => (/* binding */ NPCCollision)\n/* harmony export */ });\n/* harmony import */ var _states__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./states */ \"../../engine/source/physics/states.ts\");\n/* harmony import */ var _collision__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_collision */ \"../../engine/source/physics/_collision.ts\");\n\r\n\r\nclass NPCCollision extends _collision__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\r\n    constructor(self, from, collideswith, types) {\r\n        super(from, collideswith, types);\r\n        this.self = self;\r\n        this.padding = { x: 8, y: 8 };\r\n        self.collisions.push(this);\r\n    }\r\n    intersect(target) {\r\n        const body = { x: target.pos.x + target.hitbox.x, y: target.pos.y + target.hitbox.y, w: target.hitbox.w, h: target.hitbox.h };\r\n        const collidePoints = this.computeCollidePoints(body, this.padding);\r\n        const npcBounds = {\r\n            x: this.self.pos.x + this.self.hitbox.x,\r\n            y: this.self.pos.y + this.self.hitbox.y,\r\n            w: this.self.hitbox.w,\r\n            h: this.self.hitbox.h\r\n        };\r\n        let applyEffects = [\r\n            _states__WEBPACK_IMPORTED_MODULE_0__.CollideTypes.none,\r\n            _states__WEBPACK_IMPORTED_MODULE_0__.CollideTypes.none,\r\n            _states__WEBPACK_IMPORTED_MODULE_0__.CollideTypes.none,\r\n            _states__WEBPACK_IMPORTED_MODULE_0__.CollideTypes.none\r\n        ];\r\n        if ((body.x > npcBounds.x && body.x + this.padding.x < npcBounds.x + npcBounds.w) || (body.x + body.w - this.padding.x > npcBounds.x && body.x + body.w < npcBounds.x + npcBounds.w)) {\r\n            // Check top\r\n            applyEffects[0] |= ((npcBounds.y + npcBounds.h) - body.y > 0 && body.y > npcBounds.y) ? this.type : _states__WEBPACK_IMPORTED_MODULE_0__.CollideTypes.none;\r\n            // Check below\r\n            applyEffects[2] |= (npcBounds.y - (body.y + body.h) < 0 && body.y + body.h < npcBounds.y + npcBounds.h) ? this.type : _states__WEBPACK_IMPORTED_MODULE_0__.CollideTypes.none;\r\n        }\r\n        if ((body.y > npcBounds.y && body.y + this.padding.y < npcBounds.y + npcBounds.h) || (body.y + body.w - this.padding.y > npcBounds.y && body.y + body.w < npcBounds.y + npcBounds.h)) {\r\n            // Check left\r\n            applyEffects[1] |= ((npcBounds.x + npcBounds.w) - body.x > 0 && body.x > npcBounds.x) ? this.type : _states__WEBPACK_IMPORTED_MODULE_0__.CollideTypes.none;\r\n            // Check right\r\n            applyEffects[3] |= (npcBounds.x - (body.x + body.w) < 0 && body.x + body.w < npcBounds.x + npcBounds.w) ? this.type : _states__WEBPACK_IMPORTED_MODULE_0__.CollideTypes.none;\r\n        }\r\n        // Apply effects\r\n        for (let i = 0; i < 4; i++) {\r\n            target.activeeffects[i] |= applyEffects[i];\r\n        }\r\n    }\r\n    // Helper function to check bounds\r\n    static checkBounds(points, bounds) {\r\n        return _collision__WEBPACK_IMPORTED_MODULE_1__[\"default\"].inBounds(points[0][0], points[1][0], bounds) ||\r\n            _collision__WEBPACK_IMPORTED_MODULE_1__[\"default\"].inBounds(points[0][1], points[1][1], bounds);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///../../engine/source/physics/npcCollision.ts?\n}");

/***/ },

/***/ "../../engine/source/physics/states.ts"
/*!*********************************************!*\
  !*** ../../engine/source/physics/states.ts ***!
  \*********************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CollideLayers: () => (/* binding */ CollideLayers),\n/* harmony export */   CollideTypes: () => (/* binding */ CollideTypes)\n/* harmony export */ });\nvar CollideTypes;\r\n(function (CollideTypes) {\r\n    CollideTypes[CollideTypes[\"none\"] = 1] = \"none\";\r\n    CollideTypes[CollideTypes[\"block\"] = 2] = \"block\";\r\n    CollideTypes[CollideTypes[\"hurt\"] = 4] = \"hurt\";\r\n    CollideTypes[CollideTypes[\"interact\"] = 8] = \"interact\";\r\n    CollideTypes[CollideTypes[\"climbable\"] = 16] = \"climbable\";\r\n    CollideTypes[CollideTypes[\"water\"] = 32] = \"water\";\r\n    CollideTypes[CollideTypes[\"instakill\"] = 64] = \"instakill\";\r\n    CollideTypes[CollideTypes[\"get\"] = 128] = \"get\";\r\n    CollideTypes[CollideTypes[\"custom0\"] = 256] = \"custom0\";\r\n    CollideTypes[CollideTypes[\"custom1\"] = 512] = \"custom1\";\r\n    CollideTypes[CollideTypes[\"custom2\"] = 1024] = \"custom2\";\r\n    CollideTypes[CollideTypes[\"custom3\"] = 2048] = \"custom3\";\r\n    CollideTypes[CollideTypes[\"custom4\"] = 4096] = \"custom4\";\r\n    CollideTypes[CollideTypes[\"custom5\"] = 8192] = \"custom5\";\r\n    CollideTypes[CollideTypes[\"custom6\"] = 16384] = \"custom6\";\r\n    CollideTypes[CollideTypes[\"custom7\"] = 32768] = \"custom7\";\r\n    CollideTypes[CollideTypes[\"custom8\"] = 65536] = \"custom8\";\r\n    CollideTypes[CollideTypes[\"custom9\"] = 131072] = \"custom9\";\r\n    CollideTypes[CollideTypes[\"all\"] = 262143] = \"all\";\r\n})(CollideTypes || (CollideTypes = {}));\r\nvar CollideLayers;\r\n(function (CollideLayers) {\r\n    CollideLayers[CollideLayers[\"none\"] = 1] = \"none\";\r\n    CollideLayers[CollideLayers[\"player\"] = 2] = \"player\";\r\n    CollideLayers[CollideLayers[\"npc\"] = 4] = \"npc\";\r\n    CollideLayers[CollideLayers[\"grid\"] = 8] = \"grid\";\r\n    CollideLayers[CollideLayers[\"interactable\"] = 16] = \"interactable\";\r\n    CollideLayers[CollideLayers[\"all\"] = 31] = \"all\";\r\n})(CollideLayers || (CollideLayers = {}));\r\n\n\n//# sourceURL=webpack:///../../engine/source/physics/states.ts?\n}");

/***/ },

/***/ "../../engine/source/render/_render.ts"
/*!*********************************************!*\
  !*** ../../engine/source/render/_render.ts ***!
  \*********************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Render: () => (/* binding */ Render)\n/* harmony export */ });\n// import S\r\nvar Render;\r\n(function (Render) {\r\n    class Info {\r\n    }\r\n    // public static MAXLAYERS : number = 256;\r\n    // public static contextPool : Array<T.glContext> = [];\r\n    // protected static vbuffer: WebGLBuffer;\r\n    // protected static Rframebuffer : WebGLFramebuffer;\r\n    // protected static framebuffer : WebGLFramebuffer;\r\n    // protected static renderbuffer : WebGLRenderbuffer;\r\n    // static gl: WebGL2RenderingContext;\r\n    Info.textcanvas = (() => {\r\n        let cnv = document.createElement('canvas');\r\n        // cnv.style.display = \"none\";\r\n        cnv.width = 2048;\r\n        cnv.height = 2048;\r\n        // Enable smooth antialiasing for better text rendering\r\n        cnv.style.fontSmooth = 'always';\r\n        cnv.style.webkitFontSmoothing = 'antialiased';\r\n        cnv.style.mozOsxFontSmoothing = 'grayscale';\r\n        // document.body.prepend(cnv);\r\n        return cnv;\r\n    })();\r\n    Info.textcontext = Info.textcanvas.getContext('2d', { alpha: true, willReadFrequently: false });\r\n    Info.contextCounter = -1;\r\n    Render.Info = Info;\r\n    class GLContext extends Info {\r\n        constructor(canvas, width, height) {\r\n            super();\r\n            // console.log(canvas)\r\n            Info.contextCounter++;\r\n            // super();\r\n            // console.log(height,width);\r\n            // if(!Info.txt && document.getElementById('text')!=undefined){\r\n            //   Info.txt = (():CanvasRenderingContext2D => {\r\n            //     // document.getElementsByTagName('body')[0].clientWidth\r\n            //     document.getElementById('text').setAttribute('width', document.getElementsByTagName('body')[0].clientWidth+'');\r\n            //     document.getElementById('text').setAttribute('height',document.getElementsByTagName('body')[0].clientHeight+'');\r\n            //     return (document.querySelector('#text') as HTMLCanvasElement).\r\n            //     getContext('2d');\r\n            //   })()\r\n            //   Info.textCanvas = (document.querySelector('#text') as HTMLCanvasElement)\r\n            // }\r\n            // if(!Info.gl){\r\n            let gl = (() => {\r\n                // let cnv = document.createElement('canvas');\r\n                canvas.setAttribute(\"width\", width);\r\n                canvas.setAttribute(\"height\", height);\r\n                canvas.style.width = width + \"px\";\r\n                canvas.style.height = height + \"px\";\r\n                // document.body.appendChild(cnv);\r\n                // let ctx = (cnv as HTMLCanvasElement).getContext(\"webgl2\",\r\n                //   {premultipliedAlpha: false}\r\n                // )\r\n                // document.getElementById(\"canvas\")!.setAttribute(\"width\",  width)\r\n                // document.getElementById(\"canvas\")!.setAttribute(\"height\", height)\r\n                let ctx = canvas.\r\n                    getContext(\"webgl2\", { premultipliedAlpha: true,\r\n                    alpha: true,\r\n                    antialias: false\r\n                });\r\n                ctx.enable(ctx.BLEND);\r\n                // Premultiplied alpha blending: source RGB is already multiplied by alpha\r\n                ctx.blendFunc(ctx.ONE, ctx.ONE_MINUS_SRC_ALPHA);\r\n                return ctx;\r\n            })();\r\n            // Info.contextPool.push({\r\n            // let context = {\r\n            this.framebuffer = gl.createFramebuffer();\r\n            this.Rframebuffer = gl.createFramebuffer();\r\n            this.renderbuffer = gl.createRenderbuffer();\r\n            this.vbuffer = gl.createBuffer();\r\n            this.gl = gl;\r\n            // this.id           = String(Info.contextCounter);\r\n            this.textures = {};\r\n            // contextID    : Info.contextCounter\r\n            // }\r\n            // )\r\n            // Info.framebuffer  = Info.gl.createFramebuffer() ;\r\n            // Info.Rframebuffer = Info.gl.createFramebuffer() ;\r\n            // Info.renderbuffer = Info.gl.createRenderbuffer();\r\n            // Info.vbuffer      = Info.gl.createBuffer()      ;\r\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vbuffer);\r\n            this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([\r\n                1, 0, 0, 0, 0, 1,\r\n                1, 0, 0, 1, 1, 1 // Triangle 2\r\n            ]), this.gl.STATIC_DRAW);\r\n            this.gl.clearColor(0, 0.5, 0, 0);\r\n            this.gl.bindFramebuffer(this.gl.READ_FRAMEBUFFER, this.Rframebuffer);\r\n            this.gl.bindFramebuffer(this.gl.DRAW_FRAMEBUFFER, this.framebuffer);\r\n            this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.renderbuffer);\r\n            this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.RGBA8, 2000, 2000);\r\n            this.gl.framebufferRenderbuffer(this.gl.DRAW_FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.RENDERBUFFER, this.renderbuffer);\r\n            this.gl.readBuffer(this.gl.COLOR_ATTACHMENT0);\r\n            this.gl.drawBuffers([this.gl.COLOR_ATTACHMENT0]);\r\n            // Info.gl.drawingBufferColorSpace = \"display-p3\";\r\n            // Info.gl.unpackColorSpace = \"display-p3\";\r\n            // Info.contextPool.push(context);\r\n            // return context;\r\n        }\r\n        addTexture(name, tex) {\r\n            this.textures[name] = tex;\r\n        }\r\n        getTexture(name) {\r\n            return this.textures[name];\r\n        }\r\n    }\r\n    Render.GLContext = GLContext;\r\n    // private static resizeCanvasToDisplaySize(canvas, multiplier) {\r\n    //   multiplier = multiplier || 1;\r\n    //   const width  = canvas.clientWidth  * multiplier | 0;\r\n    //   const height = canvas.clientHeight * multiplier | 0;\r\n    //   if (canvas.width !== width ||  canvas.height !== height) {\r\n    //     canvas.width  = width;\r\n    //     canvas.height = height;\r\n    //     return true;\r\n    //   }\r\n    //   return false;\r\n    // }\r\n})(Render || (Render = {}));\r\n\n\n//# sourceURL=webpack:///../../engine/source/render/_render.ts?\n}");

/***/ },

/***/ "../../engine/source/render/_shaders.ts"
/*!**********************************************!*\
  !*** ../../engine/source/render/_shaders.ts ***!
  \**********************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Shader)\n/* harmony export */ });\nclass Shader {\r\n    constructor(gl) {\r\n        this.fallbackShader = 'normal';\r\n        this.shaders = {};\r\n        this.previousShader = \"\";\r\n        // super();\r\n        this.gl = gl;\r\n    }\r\n    getShader(id = '') {\r\n        let shader = this.shaders[id] || this.shaders[this.fallbackShader] || undefined;\r\n        if (shader === undefined) {\r\n            console.log(\"Shader \" + id + \" doesn't exist and couldn't find fallback shader \" + this.fallbackShader);\r\n        }\r\n        return shader;\r\n    }\r\n    compileShader(type, source) {\r\n        let shader = this.gl.createShader(type);\r\n        this.gl.shaderSource(shader, source);\r\n        this.gl.compileShader(shader);\r\n        let success = this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS);\r\n        if (success)\r\n            return shader;\r\n        console.debug(this.gl.getShaderInfoLog(shader));\r\n        this.gl.deleteShader(shader);\r\n        return null;\r\n    }\r\n    createProgram(vertexShader, fragmentShader) {\r\n        let program = this.gl.createProgram();\r\n        this.gl.attachShader(program, vertexShader);\r\n        this.gl.attachShader(program, fragmentShader);\r\n        this.gl.linkProgram(program);\r\n        let success = this.gl.getProgramParameter(program, this.gl.LINK_STATUS);\r\n        if (success)\r\n            return program;\r\n        console.debug(this.gl.getProgramInfoLog(program));\r\n        this.gl.deleteProgram(program);\r\n        return null;\r\n    }\r\n    passShader(cmp, plane, extraarguments = {}) {\r\n        if (cmp.rprops.shaderID != undefined)\r\n            this.validateShader(cmp.rprops.shaderID);\r\n        else\r\n            this.validateShader(this.fallbackShader);\r\n        if (this.currShader != undefined) {\r\n            // for(const a in this.currShader.first){\r\n            //   // console.log(\"A\");\r\n            //   this.currShader.first[a]();\r\n            // }\r\n            for (const a of this.currShader.second) {\r\n                a();\r\n            }\r\n            for (const a of this.currShader.passes) {\r\n                a(this.gl, cmp, plane, extraarguments);\r\n            }\r\n        }\r\n    }\r\n    validateShader(shaderID) {\r\n        if (this.previousShader !== shaderID) {\r\n            this.currShader = this.shaders[shaderID];\r\n            if (this.currShader != undefined) {\r\n                this.initShader(this.currShader);\r\n                this.previousShader = shaderID;\r\n            }\r\n            else {\r\n                console.log('Using Fallback shader');\r\n                this.currShader = this.shaders[this.fallbackShader] || undefined;\r\n                if (this.currShader != undefined)\r\n                    this.initShader(this.currShader);\r\n                else\r\n                    console.log(\"Fallback shader undefined\");\r\n                this.previousShader = this.fallbackShader;\r\n            }\r\n        }\r\n    }\r\n    initShader(sh) {\r\n        this.gl.useProgram(sh.program);\r\n        for (const a of this.currShader.first) {\r\n            a(this.gl);\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///../../engine/source/render/_shaders.ts?\n}");

/***/ },

/***/ "../../engine/source/render/assets.ts"
/*!********************************************!*\
  !*** ../../engine/source/render/assets.ts ***!
  \********************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Assets: () => (/* binding */ Assets)\n/* harmony export */ });\n/* harmony import */ var _textures__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./textures */ \"../../engine/source/render/textures.ts\");\n\r\nclass Assets {\r\n    static setprefix(prefix) {\r\n        this.pathprefix = prefix;\r\n    }\r\n    static getTexture(fileName) {\r\n        if (!Assets.textures[this.pathprefix + fileName]) {\r\n            console.log(\"Texture file not found or not loaded : \" + this.pathprefix + fileName);\r\n            return Assets.textures[this.placeholder];\r\n        }\r\n        return Assets.textures[this.pathprefix + fileName];\r\n    }\r\n    static getTextureWidth(fileName) {\r\n        if (!Assets.textures[this.pathprefix + fileName]) {\r\n            console.log(\"Texture file not found or not loaded : \" + this.pathprefix + fileName);\r\n            return -1;\r\n        }\r\n        return Assets.textures[this.pathprefix + fileName].width;\r\n    }\r\n    static getTextureHeight(fileName) {\r\n        if (!Assets.textures[this.pathprefix + fileName]) {\r\n            console.log(\"Texture file not found or not loaded : \" + this.pathprefix + fileName);\r\n            return -1;\r\n        }\r\n        return Assets.textures[this.pathprefix + fileName].height;\r\n    }\r\n    static getText(fileName) {\r\n        if (!Assets.texts[this.pathprefix + fileName]) {\r\n            console.log(\"Text file not found or not loaded : \" + this.pathprefix + fileName);\r\n            return \"\";\r\n        }\r\n        return Assets.texts[this.pathprefix + fileName];\r\n    }\r\n    static initAudio() {\r\n        Assets.audioContext = new window.AudioContext();\r\n    }\r\n    static retrieveTex(fileName, glContext) {\r\n        if (!glContext.textures[fileName]) {\r\n            // Assumes the file always exists\r\n            glContext.textures[fileName] = _textures__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createTexture(glContext, Assets.getTexture(fileName));\r\n        }\r\n        return glContext.textures[fileName];\r\n    }\r\n    static async addImage(fileName) {\r\n        if (!Assets.textures[this.pathprefix + fileName]) {\r\n            let img = new Image();\r\n            img.src = this.pathprefix + fileName;\r\n            try {\r\n                await img.decode().then(() => {\r\n                    // ne peut pas crer une texture immdiatement\r\n                    Assets.textures[this.pathprefix + fileName] = img;\r\n                });\r\n            }\r\n            catch {\r\n                console.error(\"Image not found: \" + this.pathprefix + fileName);\r\n            }\r\n        }\r\n        return this.pathprefix + fileName;\r\n    }\r\n    static async addText(fileName) {\r\n        if (!Assets.texts[this.pathprefix + fileName]) {\r\n            let txt = await fetch(this.pathprefix + fileName).then((x) => x.text())\r\n                .catch(error => {\r\n                console.error('Error loading text file: ', error);\r\n                return 'Error loading text file: ' + error;\r\n            });\r\n            Assets.texts[this.pathprefix + fileName] = txt;\r\n        }\r\n        return this.pathprefix + fileName;\r\n    }\r\n    static async addSound(fileName) {\r\n        if (!Assets.sounds[this.pathprefix + fileName]) {\r\n            await fetch(this.pathprefix + fileName)\r\n                .then(response => response.arrayBuffer())\r\n                .then(arrayBuffer => Assets.audioContext.decodeAudioData(arrayBuffer))\r\n                .then(decodedAudio => {\r\n                Assets.sounds[this.pathprefix + fileName] = decodedAudio;\r\n            })\r\n                .catch(error => console.error('Error loading audio file:', error));\r\n        }\r\n        return this.pathprefix + fileName;\r\n    }\r\n    static playSound(fileName) {\r\n        if (!Assets.sounds[this.pathprefix + fileName]) {\r\n            Assets.addSound(this.pathprefix + fileName).then((file) => Assets.play(Assets.sounds[this.pathprefix + fileName]))\r\n                .catch(error => console.error('Error loading audio file:', error));\r\n        }\r\n        else {\r\n            Assets.play(Assets.sounds[this.pathprefix + fileName]);\r\n        }\r\n    }\r\n    static play(decodedAudio) {\r\n        let source = Assets.audioContext.createBufferSource();\r\n        source.buffer = decodedAudio;\r\n        source.connect(Assets.audioContext.destination);\r\n        source.start();\r\n    }\r\n    /**\r\n     *\r\n     * @param folderPath Folder to load files from\r\n     * @param ext File extension(s) to load\r\n     * @returns Relative path of files found\r\n     */\r\n    static async loadAllExtInFolder(folderPath, ext) {\r\n        let xhr = new XMLHttpRequest();\r\n        let jobs = [];\r\n        xhr.open('GET', folderPath, false);\r\n        xhr.onreadystatechange = function () {\r\n            if (xhr.readyState === 4 && xhr.status === 200) {\r\n                let filesa = Assets.parser.parseFromString(xhr.responseText, \"text/html\").getElementsByTagName('a');\r\n                // could use files = filesa.map((f)=>{return f.getAttributes(\"href\")})\r\n                let files = [];\r\n                for (let i = 0; i < filesa.length; i++)\r\n                    files.push(filesa[i].getAttribute(\"href\"));\r\n                for (let file of files) {\r\n                    if (file.trim().length <= 0)\r\n                        continue;\r\n                    let fspl = file.split('.');\r\n                    let fileType = fspl[fspl.length - 1];\r\n                    if (fileType.endsWith('/'))\r\n                        continue;\r\n                    if (fileType.startsWith('?'))\r\n                        continue;\r\n                    if (ext.includes(fileType)) {\r\n                        if (Assets.imgExts.includes(fileType))\r\n                            jobs.push(Assets.addImage(folderPath + file));\r\n                        else if (Assets.txtExts.includes(fileType))\r\n                            jobs.push(Assets.addText(folderPath + file));\r\n                        else if (Assets.sndExts.includes(fileType))\r\n                            jobs.push(Assets.addSound(folderPath + file));\r\n                        else\r\n                            console.log('Incompatible file : ' + file);\r\n                    }\r\n                    else\r\n                        console.log('File is neither ' + ext.join(' or ') + ' : ' + file);\r\n                }\r\n            }\r\n        };\r\n        xhr.send();\r\n        await Promise.all(jobs);\r\n        return jobs;\r\n    }\r\n}\r\nAssets.pathprefix = '';\r\nAssets.parser = new DOMParser();\r\nAssets.textures = {};\r\nAssets.texts = {};\r\nAssets.sounds = {};\r\nAssets.imgExts = ['png', 'jpg', 'gif', 'jpeg'];\r\nAssets.txtExts = ['nw', 'txt', 'vert', 'frag', 'gani', 'csv'];\r\nAssets.sndExts = ['wav', 'mp3'];\r\nAssets.placeholder = \"_assets/blocking.png\";\r\n\n\n//# sourceURL=webpack:///../../engine/source/render/assets.ts?\n}");

/***/ },

/***/ "../../engine/source/render/composite.ts"
/*!***********************************************!*\
  !*** ../../engine/source/render/composite.ts ***!
  \***********************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Composite: () => (/* binding */ Composite)\n/* harmony export */ });\n/* harmony import */ var _render__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_render */ \"../../engine/source/render/_render.ts\");\n/* harmony import */ var _textures__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./textures */ \"../../engine/source/render/textures.ts\");\n/* harmony import */ var _assets__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./assets */ \"../../engine/source/render/assets.ts\");\n/* harmony import */ var _alacrity_time__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../alacrity/time */ \"../../engine/source/alacrity/time.ts\");\n\r\n\r\n\r\n\r\nvar Composite;\r\n(function (Composite_1) {\r\n    class Renderable extends _render__WEBPACK_IMPORTED_MODULE_0__.Render.Info {\r\n        constructor(glContext, shadercontext) {\r\n            super();\r\n            this.texture = undefined;\r\n            this.parent = undefined;\r\n            this.offset = { x: 0, y: 0 };\r\n            this.dirty = true;\r\n            this.usecount = 0;\r\n            this.localcorners = [{ x: 0, y: 0 }, { x: 0, y: 0 }, { x: 0, y: 0 }, { x: 0, y: 0 }];\r\n            this.glContext = glContext;\r\n            this.shadercontext = shadercontext;\r\n            this.rprops = {\r\n                srcrect: undefined,\r\n                dstrect: { x: 0, y: 0, w: 0, h: 0 },\r\n                rotcenter: { x: 0, y: 0 },\r\n                scalecenter: { x: 0, y: 0 },\r\n                pos: { x: 0, y: 0 },\r\n                flip: { flipx: false, flipy: false },\r\n                angle: 0,\r\n                scale: { x: 1, y: 1 },\r\n                layer: 0,\r\n                hidden: false,\r\n                delete: false\r\n            };\r\n        }\r\n        getClientBounds() {\r\n            return {\r\n                x: this.getClientLeft(),\r\n                y: this.getClientTop(),\r\n                w: this.getClientWidth(),\r\n                h: this.getClientHeight()\r\n            };\r\n        }\r\n        translate(offset) {\r\n            this.rprops.dstrect.x += offset.x;\r\n            this.rprops.dstrect.y += offset.y;\r\n            this.setDirty();\r\n        }\r\n        translateX(offset) {\r\n            this.rprops.dstrect.x += offset;\r\n            this.setDirty();\r\n        }\r\n        translateY(offset) {\r\n            this.rprops.dstrect.y += offset;\r\n            this.setDirty();\r\n        }\r\n        setPosition(position) {\r\n            this.rprops.dstrect.x = position.x;\r\n            this.rprops.dstrect.y = position.y;\r\n            this.setDirty();\r\n        }\r\n        setPositionX(position) {\r\n            this.rprops.dstrect.x = position;\r\n            this.setDirty();\r\n        }\r\n        setPositionY(position) {\r\n            this.rprops.dstrect.y = position;\r\n            this.setDirty();\r\n        }\r\n        setFlipX(flip) {\r\n            this.rprops.flip.flipx = flip;\r\n            this.setDirty();\r\n        }\r\n        setFlipY(flip) {\r\n            this.rprops.flip.flipy = flip;\r\n            this.setDirty();\r\n        }\r\n        setScaleX(scale) {\r\n            this.rprops.scale.x = scale;\r\n            this.setDirty();\r\n        }\r\n        setScaleY(scale) {\r\n            this.rprops.scale.y = scale;\r\n            this.setDirty();\r\n        }\r\n        setAngle(angle) {\r\n            this.rprops.angle = angle;\r\n            this.setDirty();\r\n        }\r\n        rotateBy(angle) {\r\n            this.rprops.angle += angle;\r\n            this.setDirty();\r\n        }\r\n        setLayer(layer) {\r\n            this.rprops.layer = layer;\r\n            if (this.parent)\r\n                this.parent.setDirty();\r\n        }\r\n        setDirty() {\r\n            this.dirty = true;\r\n            if (this.parent)\r\n                this.parent.setDirty();\r\n        }\r\n        // add \"add\" methods to Snap, animation, frame (or simply composite?) \r\n        //// so parent is updated at addition (instead of pushing directly)\r\n        getClientLeft() {\r\n            if (!this.parent) {\r\n                return this.rprops.pos.x * this.getWidthRatio();\r\n            }\r\n            return (this.rprops.pos.x + this.parent.getClientLeft()) * this.getWidthRatio();\r\n        }\r\n        getClientTop() {\r\n            return (this.rprops.pos.y + (this.parent == undefined ? 0 : this.parent.getClientTop())) * this.getWidthRatio();\r\n        }\r\n        getClientWidth(dstrect = this.rprops.dstrect) {\r\n            return dstrect.w * this.getWidthRatio();\r\n        }\r\n        getClientHeight(dstrect = this.rprops.dstrect) {\r\n            return dstrect.h * this.getHeightRatio();\r\n            // removed by dead control flow\n\r\n        }\r\n        getWidthRatio() {\r\n            if (this.parent != undefined) {\r\n                return (this.rprops.dstrect.w / this.rprops.srcrect.w) * this.parent.getWidthRatio();\r\n            }\r\n            return this.rprops.dstrect.w / this.rprops.srcrect.w;\r\n        }\r\n        getHeightRatio() {\r\n            if (this.parent != undefined) {\r\n                return (this.rprops.dstrect.h / this.rprops.srcrect.h) * this.parent.getHeightRatio();\r\n            }\r\n            return this.rprops.dstrect.h / this.rprops.srcrect.h;\r\n        }\r\n        retrieveTexture(fileName) {\r\n            if (!this.glContext.textures[fileName]) {\r\n                // Assumes the file always exists\r\n                this.glContext.textures[fileName] = _textures__WEBPACK_IMPORTED_MODULE_1__[\"default\"].createTexture(this.glContext, _assets__WEBPACK_IMPORTED_MODULE_2__.Assets.getTexture(fileName));\r\n            }\r\n            return this.glContext.textures[fileName];\r\n        }\r\n    }\r\n    Composite_1.Renderable = Renderable;\r\n    class Text extends Renderable {\r\n        constructor(glContext, shadercontext, text, textproperties = {}) {\r\n            super(glContext, shadercontext);\r\n            this.properties = {};\r\n            this.size = { w: 0, h: 0 };\r\n            this.supersample = 2;\r\n            this.text = text;\r\n            this.setProperties(textproperties);\r\n            Text.textcontext.textAlign = \"left\";\r\n            Text.textcontext.textBaseline = \"top\";\r\n            Text.textcontext.font = this.properties.size + \"px \" + this.properties.font;\r\n            this.rprops.dstrect.w = Text.textcontext.measureText(this.text).width;\r\n            // this.size.h = \r\n        }\r\n        compose() {\r\n            if (this.rprops.delete) {\r\n                if (this.texture !== undefined)\r\n                    this.glContext.gl.deleteTexture(this.texture);\r\n                return true;\r\n            }\r\n            if (this.dirty) {\r\n                // console.log(\"HALP\")\r\n                if (this.texture !== undefined)\r\n                    this.glContext.gl.deleteTexture(this.texture);\r\n                // Measure text first\r\n                let textcontext = Text.textcontext;\r\n                textcontext.font = this.properties.size + \"px \" + this.properties.font;\r\n                this.rprops.dstrect.w = Math.ceil(textcontext.measureText(this.text).width);\r\n                this.rprops.dstrect.h = this.properties.size;\r\n                this.size.w = this.rprops.dstrect.w * this.supersample;\r\n                this.size.h = this.rprops.dstrect.h * this.supersample;\r\n                // Clear region on shared canvas\r\n                textcontext.clearRect(0, 0, this.size.w, this.size.h);\r\n                // Set font properties\r\n                textcontext.textAlign = \"left\";\r\n                textcontext.textBaseline = \"top\";\r\n                textcontext.font = this.properties.size * this.supersample + \"px \" + this.properties.font;\r\n                textcontext.fillStyle = \"rgba(\" +\r\n                    this.properties.color.r + \",\" +\r\n                    this.properties.color.g + \",\" +\r\n                    this.properties.color.b + \",\" +\r\n                    this.properties.color.a + \")\";\r\n                // Render text\r\n                textcontext.fillText(this.text, 0, 0);\r\n                // Upload to WebGL\r\n                let gl = this.glContext.gl;\r\n                let spr = _textures__WEBPACK_IMPORTED_MODULE_1__[\"default\"].createTexToBlitOn(this.glContext, this.size.w, this.size.h);\r\n                gl.bindTexture(gl.TEXTURE_2D, spr);\r\n                // Use LINEAR filtering for smooth text antialiasing\r\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.size.w, this.size.h, 0, gl.RGBA, gl.UNSIGNED_BYTE, Text.textcanvas);\r\n                this.texture = spr;\r\n                this.dirty = false;\r\n            }\r\n            return false;\r\n        }\r\n        setText(text) {\r\n            // if(this.ready) this.glContext.gl.deleteTexture(this.texture);\r\n            this.text = text;\r\n            this.rprops.dstrect.w = Text.textcontext.measureText(this.text).width;\r\n            this.setDirty();\r\n        }\r\n        getWidth() {\r\n            return this.rprops.dstrect.w;\r\n        }\r\n        setProperties(textproperties) {\r\n            if (textproperties.size != undefined) {\r\n                this.properties.size = textproperties.size;\r\n            }\r\n            else if (this.properties.size == undefined) {\r\n                this.properties.size = 60;\r\n            }\r\n            this.size.h = this.properties.size;\r\n            if (textproperties.color != undefined) {\r\n                this.properties.color = textproperties.color;\r\n            }\r\n            else if (this.properties.color == undefined) {\r\n                this.properties.color = { r: 0, g: 0, b: 0, a: 255 };\r\n            }\r\n            if (textproperties.font != undefined) {\r\n                this.properties.font = textproperties.font;\r\n            }\r\n            else if (this.properties.font == undefined) {\r\n                this.properties.font = \"monospace\";\r\n            }\r\n            this.setDirty();\r\n        }\r\n        setColor(color) {\r\n            this.properties.color = color;\r\n            this.setDirty();\r\n        }\r\n        setSize(size) {\r\n            this.properties.size = size;\r\n            this.size.h = this.properties.size;\r\n            this.setDirty();\r\n        }\r\n    }\r\n    Composite_1.Text = Text;\r\n    class Rectangle extends Renderable {\r\n        constructor(glContext, shadercontext, bounds, color) {\r\n            super(glContext, shadercontext);\r\n            this.rprops.dstrect = bounds;\r\n            this.rprops.colorize = color;\r\n        }\r\n        compose() {\r\n            if (this.rprops.delete) {\r\n                if (this.texture !== undefined)\r\n                    this.glContext.gl.deleteTexture(this.texture);\r\n                return true;\r\n            }\r\n            if (this.dirty) {\r\n                if (this.texture !== undefined)\r\n                    this.glContext.gl.deleteTexture(this.texture);\r\n                let gl = this.glContext.gl;\r\n                let spr = _textures__WEBPACK_IMPORTED_MODULE_1__[\"default\"].createTexToBlitOn(this.glContext, 1, 1);\r\n                gl.bindFramebuffer(gl.FRAMEBUFFER, this.glContext.framebuffer);\r\n                gl.bindTexture(gl.TEXTURE_2D, spr);\r\n                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\r\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([this.rprops.colorize.r, this.rprops.colorize.g, this.rprops.colorize.b, this.rprops.colorize.a]));\r\n                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\r\n                this.texture = spr;\r\n                this.dirty = false;\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n    Composite_1.Rectangle = Rectangle;\r\n    class Image extends Renderable {\r\n        constructor(glContext, shadercontext, file, srcrect, dstrect, plane = undefined) {\r\n            super(glContext, shadercontext);\r\n            this.file = file;\r\n            this.rprops.srcrect = srcrect;\r\n            this.rprops.dstrect = dstrect;\r\n        }\r\n        compose() {\r\n            if (this.rprops.delete && this.texture) {\r\n                if (this.texture !== undefined)\r\n                    this.glContext.gl.deleteTexture(this.texture);\r\n                return true;\r\n            }\r\n            if (this.dirty) {\r\n                if (this.texture !== undefined)\r\n                    this.glContext.gl.deleteTexture(this.texture);\r\n                let gl = this.glContext.gl;\r\n                let spr = _textures__WEBPACK_IMPORTED_MODULE_1__[\"default\"].createTexToBlitOn(this.glContext, this.rprops.srcrect.w, this.rprops.srcrect.h);\r\n                gl.bindFramebuffer(gl.FRAMEBUFFER, this.glContext.framebuffer);\r\n                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.retrieveTexture(this.file), 0);\r\n                gl.bindTexture(gl.TEXTURE_2D, spr);\r\n                gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.rprops.srcrect.x, this.rprops.srcrect.y, this.rprops.srcrect.w, this.rprops.srcrect.h);\r\n                gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n                this.texture = spr;\r\n                this.dirty = false;\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n    Composite_1.Image = Image;\r\n    class Composite extends Renderable {\r\n        applyBg() { }\r\n        applyMask() { }\r\n        compose() { return this.rprops.delete; }\r\n        constructor(glContext, shadercontext) {\r\n            super(glContext, shadercontext);\r\n            this.viewport = { x: 0, y: 0, w: glContext.gl.canvas.width, h: glContext.gl.canvas.height };\r\n        }\r\n        translate(offset) {\r\n            this.rprops.pos.x += offset.x;\r\n            this.rprops.pos.y += offset.y;\r\n            this.setDirty();\r\n        }\r\n        translateX(offset) {\r\n            this.rprops.pos.x += offset;\r\n            this.setDirty();\r\n        }\r\n        translateY(offset) {\r\n            this.rprops.pos.y += offset;\r\n            this.setDirty();\r\n        }\r\n        setPosition(position) {\r\n            this.rprops.pos.x = position.x;\r\n            this.rprops.pos.y = position.y;\r\n            this.setDirty();\r\n        }\r\n        setPositionX(position) {\r\n            this.rprops.pos.x = position;\r\n            this.setDirty();\r\n        }\r\n        setPositionY(position) {\r\n            this.rprops.pos.y = position;\r\n            this.setDirty();\r\n        }\r\n        static createFocus(rd) {\r\n            let minX = Infinity;\r\n            let minY = Infinity;\r\n            let maxX = -Infinity;\r\n            let maxY = -Infinity;\r\n            for (const r of rd) {\r\n                const originX = r.rprops.dstrect.x;\r\n                const originY = r.rprops.dstrect.y;\r\n                let localcorners;\r\n                // if(r.dirty){\r\n                localcorners = [\r\n                    { x: 0, y: 0 },\r\n                    { x: r.rprops.dstrect.w, y: 0 },\r\n                    { x: 0, y: r.rprops.dstrect.h },\r\n                    { x: r.rprops.dstrect.w, y: r.rprops.dstrect.h },\r\n                ];\r\n                // } else {\r\n                //   localcorners = r.localcorners;\r\n                // }\r\n                for (let i = 0; i < localcorners.length; i++) {\r\n                    let transformed;\r\n                    // if(r.dirty){\r\n                    transformed = Composite.scaleThenRotatePreserveOriginalRotation(localcorners[i], r.rprops.scalecenter || { x: 0, y: 0 }, r.rprops.scale || { x: 1, y: 1 }, r.rprops.rotcenter || { x: 0, y: 0 }, -r.rprops.angle || 0);\r\n                    r.localcorners[i] = transformed;\r\n                    // } else {\r\n                    //   transformed = localcorners[i];\r\n                    // }\r\n                    const absoluteX = originX + transformed.x;\r\n                    const absoluteY = originY + transformed.y;\r\n                    minX = Math.min(minX, absoluteX);\r\n                    minY = Math.min(minY, absoluteY);\r\n                    maxX = Math.max(maxX, absoluteX);\r\n                    maxY = Math.max(maxY, absoluteY);\r\n                }\r\n            }\r\n            return {\r\n                x: Math.floor(minX),\r\n                y: Math.floor(minY),\r\n                w: Math.ceil(maxX - Math.floor(minX)),\r\n                h: Math.ceil(maxY - Math.floor(minY))\r\n            };\r\n        }\r\n        setDirty() {\r\n            this.dirty = true;\r\n            if (this.parent)\r\n                this.parent.setDirty();\r\n        }\r\n        generateComposite(rd, focusRect) {\r\n            let toDraw = rd.filter((r) => { return !r?.rprops.hidden; });\r\n            if (toDraw.length > 0) {\r\n                toDraw.sort((a, b) => a.rprops.layer - b.rprops.layer);\r\n                // for(let i = 0; i < toDraw.length; i++) toDraw[i].compose();\r\n                this.offset.x = focusRect.x;\r\n                this.offset.y = focusRect.y;\r\n                this.rprops.dstrect = {\r\n                    x: this.rprops.pos.x + focusRect.x,\r\n                    y: this.rprops.pos.y + focusRect.y,\r\n                    w: focusRect.w,\r\n                    h: focusRect.h\r\n                };\r\n                let gl = this.glContext.gl;\r\n                gl.bindFramebuffer(gl.FRAMEBUFFER, this.glContext.framebuffer);\r\n                this.texture = _textures__WEBPACK_IMPORTED_MODULE_1__[\"default\"].createTexToBlitOn(this.glContext, focusRect.w, focusRect.h);\r\n                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);\r\n                gl.viewport(0, 0, focusRect.w, focusRect.h);\r\n                gl.clearColor(1, 0, 0, .1);\r\n                gl.clear(gl.COLOR_BUFFER_BIT);\r\n                for (let i = 0; i < toDraw.length; i++) {\r\n                    this.glContext.gl.bindTexture(gl.TEXTURE_2D, toDraw[i].texture);\r\n                    const childPlane = {\r\n                        x: toDraw[i].rprops.dstrect.x - focusRect.x,\r\n                        y: toDraw[i].rprops.dstrect.y - focusRect.y,\r\n                        w: focusRect.w,\r\n                        h: focusRect.h\r\n                    };\r\n                    this.shadercontext.passShader(toDraw[i], childPlane);\r\n                    gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n                }\r\n                this.ready = true;\r\n            }\r\n            else\r\n                this.ready = false;\r\n        }\r\n        // add \"add\" methods to Snap, animation, frame (or simply composite?) \r\n        //// so parent is updated at addition (instead of pushing directly)\r\n        // need to refresh camera for viewport to have the camera modifications\r\n        getClientLeft() {\r\n            if (!this.parent) {\r\n                return this.rprops.pos.x - this.viewport.x;\r\n            }\r\n            return this.rprops.pos.x + this.parent.getClientLeft() - this.viewport.x;\r\n        }\r\n        getClientTop() {\r\n            return this.rprops.pos.y + (this.parent == undefined ? 0 : this.parent.getClientTop()) - this.viewport.y;\r\n        }\r\n        addToComposition(arr) { }\r\n        static rotateAround(p, center, angleRad) {\r\n            const cos = Math.cos(angleRad);\r\n            const sin = Math.sin(angleRad);\r\n            const dx = p.x - center.x;\r\n            const dy = p.y - center.y;\r\n            return {\r\n                x: center.x + dx * cos - dy * sin,\r\n                y: center.y + dx * sin + dy * cos,\r\n            };\r\n        }\r\n        static scaleAround(p, center, scale) {\r\n            return {\r\n                x: center.x + (p.x - center.x) * scale.x,\r\n                y: center.y + (p.y - center.y) * scale.y,\r\n            };\r\n        }\r\n        static scaleThenRotatePreserveOriginalRotation(p, scaleCenter, scale, rotationCenter, angleRad) {\r\n            // 1) scale the point\r\n            let scaledpoint = p;\r\n            let compensatedRotationCenter = rotationCenter;\r\n            if (scale.x != 1 || scale.y != 1) {\r\n                scaledpoint = Composite.scaleAround(p, scaleCenter, scale);\r\n                // 2) compensate the rotation center\r\n                compensatedRotationCenter = {\r\n                    x: scaleCenter.x + (rotationCenter.x - scaleCenter.x) * scale.x,\r\n                    y: scaleCenter.y + (rotationCenter.y - scaleCenter.y) * scale.y,\r\n                };\r\n            }\r\n            // 3) rotate around the compensated center\r\n            if (angleRad != 0) {\r\n                return Composite.rotateAround(scaledpoint, compensatedRotationCenter, angleRad);\r\n            }\r\n            return scaledpoint;\r\n        }\r\n    }\r\n    class Snap extends Composite {\r\n        constructor(glContext, shadercontext, parts) {\r\n            super(glContext, shadercontext);\r\n            for (let p of parts) {\r\n                p.parent = this;\r\n                p.usecount += 1;\r\n            }\r\n            this.parts = parts;\r\n        }\r\n        compose() {\r\n            if (this.rprops.delete) {\r\n                if (this.texture !== undefined)\r\n                    this.glContext.gl.deleteTexture(this.texture);\r\n                for (let f of this.parts) {\r\n                    f.usecount -= 1;\r\n                    if (f.usecount <= 0) {\r\n                        f.rprops.delete = true;\r\n                        f.compose();\r\n                    }\r\n                }\r\n                return true;\r\n            }\r\n            if (this.dirty) {\r\n                if (this.texture !== undefined)\r\n                    this.glContext.gl.deleteTexture(this.texture);\r\n                this.parts = this.parts.filter((f) => f != undefined && !f.compose());\r\n                this.focus = Snap.createFocus(this.parts);\r\n                this.generateComposite(this.parts, this.focus);\r\n                this.dirty = false;\r\n            }\r\n            return false;\r\n        }\r\n        addToComposition(arr) {\r\n            for (let a of arr) {\r\n                a.usecount += 1;\r\n                a.parent = this;\r\n            }\r\n            this.parts.push(...arr);\r\n        }\r\n    }\r\n    Composite_1.Snap = Snap;\r\n    class Animation extends Composite {\r\n        constructor(glContext, shadercontext, frames, timings = [200]) {\r\n            super(glContext, shadercontext);\r\n            this.currentFrame = 0;\r\n            // this.dynamic = true;\r\n            this.timer = new _alacrity_time__WEBPACK_IMPORTED_MODULE_3__.Time.Timeout(timings, \"framechange\");\r\n            this.frames = frames;\r\n            for (let f of frames) {\r\n                f.usecount += 1;\r\n                f.parent = this;\r\n            }\r\n        }\r\n        compose() {\r\n            if (this.rprops.delete) {\r\n                if (this.texture !== undefined)\r\n                    this.glContext.gl.deleteTexture(this.texture);\r\n                for (let f of this.frames) {\r\n                    f.usecount -= 1;\r\n                    if (f.usecount <= 0) {\r\n                        f.rprops.delete = true;\r\n                        f.compose();\r\n                    }\r\n                }\r\n                return true;\r\n            }\r\n            this.handleFrameChange();\r\n            if (this.frames[this.currentFrame].dirty) {\r\n                this.frames[this.currentFrame].compose();\r\n            }\r\n            this.texture = this.frames[this.currentFrame].texture;\r\n            this.rprops = this.frames[this.currentFrame].rprops;\r\n            this.dirty = this.frames[this.currentFrame].dirty;\r\n            return false;\r\n        }\r\n        handleFrameChange() {\r\n            let trig = this.timer.test();\r\n            if (trig.state == 'triggered') {\r\n                this.currentFrame += 1;\r\n                if (this.currentFrame >= this.frames.length)\r\n                    this.currentFrame = 0;\r\n            }\r\n        }\r\n        pause() {\r\n            this.timer.pause();\r\n        }\r\n        resume() {\r\n            this.timer.resume();\r\n        }\r\n        restart() {\r\n            this.timer.restart();\r\n            this.currentFrame = 0;\r\n        }\r\n        // these are present because of a bug linking animation position, \r\n        // currently, i need to link every of its frames to the animation's parent position\r\n        // it works but is incorrect and may lead to future malfunctioning\r\n        //\r\n        getClientLeft() {\r\n            return this.parent.getClientLeft();\r\n        }\r\n        getClientTop() {\r\n            return this.parent.getClientTop();\r\n        }\r\n        // returns and diminishes once too many?\r\n        getClientWidth() {\r\n            return super.getClientWidth(this.frames[this.currentFrame].rprops.dstrect);\r\n        }\r\n        getClientHeight() {\r\n            return super.getClientHeight(this.frames[this.currentFrame].rprops.dstrect);\r\n        }\r\n        addToComposition(arr) {\r\n            for (let a of arr) {\r\n                a.parent = this;\r\n            }\r\n            this.frames.push(...arr);\r\n        }\r\n    }\r\n    Composite_1.Animation = Animation;\r\n    class Frame extends Composite {\r\n        constructor(glContext, shadercontext, frame, size = { w: 0, h: 0 }) {\r\n            super(glContext, shadercontext);\r\n            this.camera = undefined;\r\n            this.picture = { crop: { do: false, w: 0, h: 0 }, x: 0, y: 0, w: 0, h: 0, img: undefined, ready: false };\r\n            this.frame = frame;\r\n            // this.dynamic = true;\r\n            this.rprops.dstrect.w = size.w;\r\n            this.rprops.dstrect.h = size.h;\r\n            for (let f of frame) {\r\n                f.usecount += 1;\r\n                f.parent = this;\r\n            }\r\n        }\r\n        compose() {\r\n            // There has to be an underlying bug for this next line to be required:\r\n            if (this.frame[0] === undefined) {\r\n                console.log(\"Skipping empty frame...\");\r\n                return true;\r\n            }\r\n            if (this.rprops.delete) {\r\n                if (this.texture !== undefined)\r\n                    this.glContext.gl.deleteTexture(this.texture);\r\n                for (let f of this.frame) {\r\n                    f.usecount -= 1;\r\n                    if (f.usecount <= 0) {\r\n                        f.rprops.delete = true;\r\n                        f.compose();\r\n                    }\r\n                }\r\n                return true;\r\n            }\r\n            if (this.dirty) {\r\n                if (this.texture !== undefined)\r\n                    this.glContext.gl.deleteTexture(this.texture);\r\n                this.frame = this.frame.filter((f) => f != undefined && !f.compose());\r\n                let focusRect = Snap.createFocus(this.frame.filter((f) => f != undefined && !f.rprops.delete && !f.rprops.hidden));\r\n                let parts = this.frame;\r\n                this.rprops.dstrect.x = this.rprops.pos.x;\r\n                this.rprops.dstrect.y = this.rprops.pos.y;\r\n                if (this.camera !== undefined) {\r\n                    this.rprops.dstrect.w = this.camera.viewport.w;\r\n                    this.rprops.dstrect.h = this.camera.viewport.h;\r\n                    this.viewport = { x: this.camera.viewport.x, y: this.camera.viewport.y, w: this.camera.viewport.w, h: this.camera.viewport.h };\r\n                }\r\n                if (parts.length > 0)\r\n                    this.generateComposite(parts, focusRect);\r\n                if (this.picture.crop.do)\r\n                    this.crop();\r\n                this.dirty = false;\r\n            }\r\n            return false;\r\n        }\r\n        crop() {\r\n            if (this.picture.ready) {\r\n                this.glContext.gl.deleteTexture(this.glContext.getTexture('croptex'));\r\n                this.picture.ready = false;\r\n            }\r\n            if (!this.picture.ready) {\r\n                this.glContext.addTexture('croptex', this.texture);\r\n                let img = new Image(this.glContext, this.shadercontext, 'croptex', { x: 0, y: 0, w: this.picture.crop.w, h: this.picture.crop.h }, { x: 0, y: 0, w: this.picture.w, h: this.picture.h });\r\n                img.compose();\r\n                this.texture = img.texture;\r\n                this.rprops.pos.x = this.picture.x;\r\n                this.rprops.pos.y = this.picture.y;\r\n                this.rprops.dstrect.w = this.picture.w;\r\n                this.rprops.dstrect.h = this.picture.h;\r\n                this.picture.ready = true;\r\n            }\r\n        }\r\n        setCrop(crop, dest) {\r\n            this.picture =\r\n                { crop: { do: true, ...crop }, ...dest, img: undefined, ready: false };\r\n        }\r\n        addToComposition(arr) {\r\n            for (let a of arr) {\r\n                a.parent = this;\r\n            }\r\n            this.frame.push(...arr);\r\n            this.setDirty();\r\n        }\r\n    }\r\n    Composite_1.Frame = Frame;\r\n})(Composite || (Composite = {}));\r\n\n\n//# sourceURL=webpack:///../../engine/source/render/composite.ts?\n}");

/***/ },

/***/ "../../engine/source/render/shaderloader.ts"
/*!**************************************************!*\
  !*** ../../engine/source/render/shaderloader.ts ***!
  \**************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShaderLoader: () => (/* binding */ ShaderLoader)\n/* harmony export */ });\n/* harmony import */ var _shaders__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_shaders */ \"../../engine/source/render/_shaders.ts\");\n/* harmony import */ var _assets__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assets */ \"../../engine/source/render/assets.ts\");\n/* harmony import */ var _shaders_reverser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shaders/reverser */ \"../../engine/source/render/shaders/reverser.ts\");\n/* harmony import */ var _shaders_normal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shaders/normal */ \"../../engine/source/render/shaders/normal.ts\");\n/* harmony import */ var _shaders_whitetransparent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shaders/whitetransparent */ \"../../engine/source/render/shaders/whitetransparent.ts\");\n\r\n\r\n\r\n\r\n\r\nclass ShaderLoader extends _shaders__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n    constructor(gl, shaderts = [new _shaders_normal__WEBPACK_IMPORTED_MODULE_3__.Normal(), new _shaders_reverser__WEBPACK_IMPORTED_MODULE_2__.Reverser(), new _shaders_whitetransparent__WEBPACK_IMPORTED_MODULE_4__.WhiteTransparent()]) {\r\n        super(gl);\r\n        this.shaderts = shaderts;\r\n    }\r\n    async init() {\r\n        if (!ShaderLoader.initialized)\r\n            await this.compileAllShadersFrom(\"shaders/\");\r\n        ShaderLoader.initialized = true;\r\n    }\r\n    async compileAllShadersFrom(folder) {\r\n        let programs = [];\r\n        await Promise.all(await _assets__WEBPACK_IMPORTED_MODULE_1__.Assets.loadAllExtInFolder(folder, [\"frag\", \"vert\"]))\r\n            .then((q) => {\r\n            q.map((val, idx, arr) => {\r\n                let name = val.split('/')[1].split('.')[0];\r\n                for (let i = idx; i < arr.length; i++) {\r\n                    if (name == arr[i].split('/')[1].split('.')[0] && !programs.includes(name)) {\r\n                        programs.push(name);\r\n                    }\r\n                }\r\n            });\r\n        });\r\n        ;\r\n        for (let i = 0; i < programs.length; i++) {\r\n            this.shaders[programs[i]] = (() => {\r\n                let vertexShader = this.compileShader(this.gl.VERTEX_SHADER, _assets__WEBPACK_IMPORTED_MODULE_1__.Assets.getText(\"shaders/\" + programs[i] + \".vert\"));\r\n                let fragmentShader = this.compileShader(this.gl.FRAGMENT_SHADER, _assets__WEBPACK_IMPORTED_MODULE_1__.Assets.getText(\"shaders/\" + programs[i] + \".frag\"));\r\n                let program = this.createProgram(vertexShader, fragmentShader);\r\n                if (!program) {\r\n                    console.log(\"Shader creation unsuccessful:\" + this.shaders[programs[i]]);\r\n                }\r\n                for (let j = 0; j < this.shaderts.length; j++) {\r\n                    if (this.shaderts[j].name == programs[i]) {\r\n                        if (program != null) {\r\n                            this.shaderts[j].program = program;\r\n                            return this.shaderts[j];\r\n                        }\r\n                    }\r\n                }\r\n                // If unsuccessful, revert to first loaded shader\r\n                // Should return default shader, for now it is first in the list\r\n                // of loaded shaders (shaderts:Array<Shader>)\r\n                return this.shaderts[0];\r\n            })();\r\n        }\r\n        return programs;\r\n    }\r\n}\r\nShaderLoader.initialized = false;\r\n\n\n//# sourceURL=webpack:///../../engine/source/render/shaderloader.ts?\n}");

/***/ },

/***/ "../../engine/source/render/shaders/matrices.ts"
/*!******************************************************!*\
  !*** ../../engine/source/render/shaders/matrices.ts ***!
  \******************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Matrix)\n/* harmony export */ });\n// Taken from www.webglfundamentals.com or something\r\nclass Matrix {\r\n    static ortho(x, y, z, w, h, d) {\r\n        return new Float32Array([\r\n            w, 0, 0, 0,\r\n            0, h, 0, 0,\r\n            0, 0, d, 0,\r\n            x, y, z, 1\r\n        ]);\r\n    }\r\n    static multiplyMatrices(matrixA, matrixB) {\r\n        // Slice the second matrix up into rows\r\n        let row0 = [matrixB[0], matrixB[1], matrixB[2], matrixB[3]];\r\n        let row1 = [matrixB[4], matrixB[5], matrixB[6], matrixB[7]];\r\n        let row2 = [matrixB[8], matrixB[9], matrixB[10], matrixB[11]];\r\n        let row3 = [matrixB[12], matrixB[13], matrixB[14], matrixB[15]];\r\n        // Multiply each row by matrixA\r\n        let result0 = this.multiplyMatrixAndPoint(matrixA, row0);\r\n        let result1 = this.multiplyMatrixAndPoint(matrixA, row1);\r\n        let result2 = this.multiplyMatrixAndPoint(matrixA, row2);\r\n        let result3 = this.multiplyMatrixAndPoint(matrixA, row3);\r\n        // Turn the result rows back into a single matrix\r\n        return new Float32Array([\r\n            result0[0],\r\n            result0[1],\r\n            result0[2],\r\n            result0[3],\r\n            result1[0],\r\n            result1[1],\r\n            result1[2],\r\n            result1[3],\r\n            result2[0],\r\n            result2[1],\r\n            result2[2],\r\n            result2[3],\r\n            result3[0],\r\n            result3[1],\r\n            result3[2],\r\n            result3[3]\r\n        ]);\r\n    }\r\n    static multiplyMatrixAndPoint(matrix, point) {\r\n        // Give a simple variable name to each part of the matrix, a column and row number\r\n        let c0r0 = matrix[0], c1r0 = matrix[1], c2r0 = matrix[2], c3r0 = matrix[3];\r\n        let c0r1 = matrix[4], c1r1 = matrix[5], c2r1 = matrix[6], c3r1 = matrix[7];\r\n        let c0r2 = matrix[8], c1r2 = matrix[9], c2r2 = matrix[10], c3r2 = matrix[11];\r\n        let c0r3 = matrix[12], c1r3 = matrix[13], c2r3 = matrix[14], c3r3 = matrix[15];\r\n        // Now set some simple names for the point\r\n        let x = point[0];\r\n        let y = point[1];\r\n        let z = point[2];\r\n        let w = point[3];\r\n        // Multiply the point against each part of the 1st column, then add together\r\n        let resultX = x * c0r0 + y * c0r1 + z * c0r2 + w * c0r3;\r\n        // Multiply the point against each part of the 2nd column, then add together\r\n        let resultY = x * c1r0 + y * c1r1 + z * c1r2 + w * c1r3;\r\n        // Multiply the point against each part of the 3rd column, then add together\r\n        let resultZ = x * c2r0 + y * c2r1 + z * c2r2 + w * c2r3;\r\n        // Multiply the point against each part of the 4th column, then add together\r\n        let resultW = x * c3r0 + y * c3r1 + z * c3r2 + w * c3r3;\r\n        return [resultX, resultY, resultZ, resultW];\r\n    }\r\n    static rotation(dst, radians) {\r\n        return this.multiplyMatrices(dst, [\r\n            Math.cos(radians), -Math.sin(radians), 0, 0,\r\n            Math.sin(radians), Math.cos(radians), 0, 0,\r\n            0, 0, 1, 0,\r\n            0, 0, 0, 1,\r\n        ]);\r\n    }\r\n    static normalize(dst, width, height) {\r\n        dst[0] = dst[0] / width;\r\n        dst[5] = dst[5] / height;\r\n        dst[12] = dst[12] / width;\r\n        dst[13] = dst[13] / height;\r\n        return dst;\r\n    }\r\n    static orthographic(left, right, bottom, top, near, far, dst = new Float32Array(16)) {\r\n        dst[0] = 2 / (right - left);\r\n        dst[1] = 0;\r\n        dst[2] = 0;\r\n        dst[3] = 0;\r\n        dst[4] = 0;\r\n        dst[5] = 2 / (top - bottom);\r\n        dst[6] = 0;\r\n        dst[7] = 0;\r\n        dst[8] = 0;\r\n        dst[9] = 0;\r\n        dst[10] = 2 / (near - far);\r\n        dst[11] = 0;\r\n        dst[12] = (left + right) / (left - right);\r\n        dst[13] = (bottom + top) / (bottom - top);\r\n        dst[14] = (near + far) / (near - far);\r\n        dst[15] = 1;\r\n        return dst;\r\n    }\r\n    static scale(m, sx, sy, sz, dst = new Float32Array(16)) {\r\n        dst[0] = sx * m[0 * 4 + 0];\r\n        dst[1] = sx * m[0 * 4 + 1];\r\n        dst[2] = sx * m[0 * 4 + 2];\r\n        dst[3] = sx * m[0 * 4 + 3];\r\n        dst[4] = sy * m[1 * 4 + 0];\r\n        dst[5] = sy * m[1 * 4 + 1];\r\n        dst[6] = sy * m[1 * 4 + 2];\r\n        dst[7] = sy * m[1 * 4 + 3];\r\n        dst[8] = sz * m[2 * 4 + 0];\r\n        dst[9] = sz * m[2 * 4 + 1];\r\n        dst[10] = sz * m[2 * 4 + 2];\r\n        dst[11] = sz * m[2 * 4 + 3];\r\n        if (m !== dst) {\r\n            dst[12] = m[12];\r\n            dst[13] = m[13];\r\n            dst[14] = m[14];\r\n            dst[15] = m[15];\r\n        }\r\n        return dst;\r\n    }\r\n    static translate(m, tx, ty, tz, dst = new Float32Array(16)) {\r\n        var m00 = m[0];\r\n        var m01 = m[1];\r\n        var m02 = m[2];\r\n        var m03 = m[3];\r\n        var m10 = m[1 * 4 + 0];\r\n        var m11 = m[1 * 4 + 1];\r\n        var m12 = m[1 * 4 + 2];\r\n        var m13 = m[1 * 4 + 3];\r\n        var m20 = m[2 * 4 + 0];\r\n        var m21 = m[2 * 4 + 1];\r\n        var m22 = m[2 * 4 + 2];\r\n        var m23 = m[2 * 4 + 3];\r\n        var m30 = m[3 * 4 + 0];\r\n        var m31 = m[3 * 4 + 1];\r\n        var m32 = m[3 * 4 + 2];\r\n        var m33 = m[3 * 4 + 3];\r\n        if (m !== dst) {\r\n            dst[0] = m00;\r\n            dst[1] = m01;\r\n            dst[2] = m02;\r\n            dst[3] = m03;\r\n            dst[4] = m10;\r\n            dst[5] = m11;\r\n            dst[6] = m12;\r\n            dst[7] = m13;\r\n            dst[8] = m20;\r\n            dst[9] = m21;\r\n            dst[10] = m22;\r\n            dst[11] = m23;\r\n        }\r\n        dst[12] = m00 * tx + m10 * ty + m20 * tz + m30;\r\n        dst[13] = m01 * tx + m11 * ty + m21 * tz + m31;\r\n        dst[14] = m02 * tx + m12 * ty + m22 * tz + m32;\r\n        dst[15] = m03 * tx + m13 * ty + m23 * tz + m33;\r\n        return dst;\r\n    }\r\n    static mat4mul(lefthand, righthand) {\r\n        const result = [];\r\n        for (let row = 0; row < 4; row++) {\r\n            for (let col = 0; col < 4; col++) {\r\n                const value = lefthand[row * 4 + 0] * righthand[0 * 4 + col]\r\n                    + lefthand[row * 4 + 1] * righthand[1 * 4 + col]\r\n                    + lefthand[row * 4 + 2] * righthand[2 * 4 + col]\r\n                    + lefthand[row * 4 + 3] * righthand[3 * 4 + col];\r\n                result[row * 4 + col] = value;\r\n            }\r\n        }\r\n        return new Float32Array(result);\r\n    }\r\n    static mat4translation(point) {\r\n        return new Float32Array([\r\n            1.0, 0.0, 0.0, 0.0,\r\n            0.0, 1.0, 0.0, 0.0,\r\n            0.0, 0.0, 1.0, 0.0,\r\n            point.x, point.y, 0.0, 1.0\r\n        ]);\r\n    }\r\n    static mat4rot(radians) {\r\n        return new Float32Array([\r\n            Math.cos(radians), -Math.sin(radians), 0, 0,\r\n            Math.sin(radians), Math.cos(radians), 0, 0,\r\n            0, 0, 1, 0,\r\n            0, 0, 0, 1,\r\n        ]);\r\n    }\r\n}\r\nMatrix.iM = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\r\n\n\n//# sourceURL=webpack:///../../engine/source/render/shaders/matrices.ts?\n}");

/***/ },

/***/ "../../engine/source/render/shaders/normal.ts"
/*!****************************************************!*\
  !*** ../../engine/source/render/shaders/normal.ts ***!
  \****************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Normal: () => (/* binding */ Normal)\n/* harmony export */ });\n/* harmony import */ var _template__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./template */ \"../../engine/source/render/shaders/template.ts\");\n/* harmony import */ var _matrices__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./matrices */ \"../../engine/source/render/shaders/matrices.ts\");\n\r\n\r\nclass Normal extends _template__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = \"normal\";\r\n        // public texture : WebGLUniformLocation;\r\n        this.second = [\r\n            () => { }\r\n        ];\r\n        this.first = [\r\n            (ctx) => {\r\n                let gl = ctx;\r\n                let aVertexPosition = gl.getAttribLocation(this.program, \"aVertexPosition\");\r\n                gl.enableVertexAttribArray(aVertexPosition);\r\n                gl.vertexAttribPointer(aVertexPosition, 2, gl.FLOAT, false, 0, 0);\r\n                let texCoordLocation = gl.getAttribLocation(this.program, \"texcoordLocation\");\r\n                gl.enableVertexAttribArray(texCoordLocation);\r\n                gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);\r\n                this.matrixLocation = gl.getUniformLocation(this.program, \"matrixLocation\");\r\n                this.textureMatrixLocation = gl.getUniformLocation(this.program, \"textureMatrixLocation\");\r\n            },\r\n        ];\r\n        this.passes = [\r\n            (ctx, cmp, plane, extraarguments) => {\r\n                let gl = ctx;\r\n                let normalizedHeight = cmp.rprops.dstrect.h * (-2 / plane.h);\r\n                let normalizedWidth = cmp.rprops.dstrect.w * (2 / plane.w);\r\n                let positionMatrix = new Float32Array([normalizedWidth, 0, 0, 0,\r\n                    0, normalizedHeight, 0, 0,\r\n                    0, 0, 1, 0,\r\n                    0, 0, 0, 1]);\r\n                let scaleoffset = { x: 0, y: 0 };\r\n                if (cmp.rprops.scalecenter != undefined) {\r\n                    scaleoffset = { x: cmp.rprops.scalecenter.x * (2 / plane.w),\r\n                        y: cmp.rprops.scalecenter.y * (-2 / plane.h) };\r\n                }\r\n                scaleoffset = { x: (0 - scaleoffset.x) * cmp.rprops.scale.x + scaleoffset.x,\r\n                    y: normalizedHeight - (normalizedHeight - scaleoffset.y) * cmp.rprops.scale.y - scaleoffset.y };\r\n                positionMatrix = _matrices__WEBPACK_IMPORTED_MODULE_1__[\"default\"].mat4mul(positionMatrix, _matrices__WEBPACK_IMPORTED_MODULE_1__[\"default\"].mat4translation({ x: scaleoffset.x, y: scaleoffset.y }));\r\n                positionMatrix = _matrices__WEBPACK_IMPORTED_MODULE_1__[\"default\"].scale(positionMatrix, cmp.rprops.scale.x, cmp.rprops.scale.y, 1);\r\n                let rotcenter = { x: 0, y: 0 };\r\n                if (cmp.rprops.rotcenter != undefined) {\r\n                    rotcenter = { x: cmp.rprops.rotcenter.x * (2 / plane.w), y: ((cmp.rprops.dstrect.h - cmp.rprops.rotcenter.y)) * (-2 / plane.h) };\r\n                }\r\n                positionMatrix = _matrices__WEBPACK_IMPORTED_MODULE_1__[\"default\"].mat4mul(positionMatrix, _matrices__WEBPACK_IMPORTED_MODULE_1__[\"default\"].mat4translation({ x: -rotcenter.x, y: -rotcenter.y }));\r\n                positionMatrix = _matrices__WEBPACK_IMPORTED_MODULE_1__[\"default\"].mat4mul(positionMatrix, _matrices__WEBPACK_IMPORTED_MODULE_1__[\"default\"].mat4rot(cmp.rprops.angle));\r\n                positionMatrix = _matrices__WEBPACK_IMPORTED_MODULE_1__[\"default\"].mat4mul(positionMatrix, _matrices__WEBPACK_IMPORTED_MODULE_1__[\"default\"].mat4translation({ x: rotcenter.x, y: rotcenter.y }));\r\n                positionMatrix[12] += Math.round(plane.x) * (2 / plane.w) - 1;\r\n                positionMatrix[13] += -(Math.round(plane.h - plane.y - cmp.rprops.dstrect.h) * (2 / plane.h)) + 1;\r\n                gl.uniformMatrix4fv(this.matrixLocation, false, positionMatrix);\r\n                if (this.textureMatrixLocation != null) {\r\n                    let texMatrix = _matrices__WEBPACK_IMPORTED_MODULE_1__[\"default\"].orthographic(-1, 1, -1, 1, -1, 1);\r\n                    texMatrix = _matrices__WEBPACK_IMPORTED_MODULE_1__[\"default\"].translate(texMatrix, 0, 1, 0);\r\n                    if (cmp.rprops.flip.flipx && cmp.rprops.flip.flipy) {\r\n                        texMatrix = _matrices__WEBPACK_IMPORTED_MODULE_1__[\"default\"].orthographic(1, -1, 1, -1, -1, 1);\r\n                        texMatrix = _matrices__WEBPACK_IMPORTED_MODULE_1__[\"default\"].translate(texMatrix, -1, 0, 0);\r\n                    }\r\n                    else if (cmp.rprops.flip.flipx) {\r\n                        texMatrix = _matrices__WEBPACK_IMPORTED_MODULE_1__[\"default\"].orthographic(1, -1, -1, 1, -1, 1);\r\n                        texMatrix = _matrices__WEBPACK_IMPORTED_MODULE_1__[\"default\"].translate(texMatrix, -1, 1, 0);\r\n                    }\r\n                    else if (cmp.rprops.flip.flipy) {\r\n                        texMatrix = _matrices__WEBPACK_IMPORTED_MODULE_1__[\"default\"].orthographic(-1, 1, 1, -1, -1, 1);\r\n                    }\r\n                    gl.uniformMatrix4fv(this.textureMatrixLocation, false, texMatrix);\r\n                }\r\n            }\r\n        ];\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///../../engine/source/render/shaders/normal.ts?\n}");

/***/ },

/***/ "../../engine/source/render/shaders/reverser.ts"
/*!******************************************************!*\
  !*** ../../engine/source/render/shaders/reverser.ts ***!
  \******************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Reverser: () => (/* binding */ Reverser)\n/* harmony export */ });\n/* harmony import */ var _template__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./template */ \"../../engine/source/render/shaders/template.ts\");\n/* harmony import */ var _matrices__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./matrices */ \"../../engine/source/render/shaders/matrices.ts\");\n\r\n\r\nclass Reverser extends _template__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = \"reverser\";\r\n        // public texture : WebGLUniformLocation;\r\n        this.second = [\r\n            () => { }\r\n        ];\r\n        this.first = [\r\n            (ctx) => {\r\n                let gl = ctx;\r\n                let aVertexPosition = gl.getAttribLocation(this.program, \"aVertexPosition\");\r\n                gl.enableVertexAttribArray(aVertexPosition);\r\n                gl.vertexAttribPointer(aVertexPosition, 2, gl.FLOAT, false, 0, 0);\r\n                let texCoordLocation = gl.getAttribLocation(this.program, \"texcoordLocation\");\r\n                gl.enableVertexAttribArray(texCoordLocation);\r\n                gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);\r\n                this.matrixLocation = gl.getUniformLocation(this.program, \"matrixLocation\");\r\n                this.textureMatrixLocation = gl.getUniformLocation(this.program, \"textureMatrixLocation\");\r\n                // this.texture = gl.getUniformLocation(this.program, \"texture\");\r\n            },\r\n        ];\r\n        this.passes = [\r\n            (ctx, cmp, plane, extraarguments) => {\r\n                let gl = ctx;\r\n                let positionmatrix = new Float32Array([cmp.rprops.dstrect.w, 0, 0, 0,\r\n                    0, cmp.rprops.dstrect.h, 0, 0,\r\n                    0, 0, 1, 0,\r\n                    plane.x, plane.y, 0, 1]);\r\n                positionmatrix[0] *= 2 / plane.w;\r\n                positionmatrix[5] *= -2 / plane.h;\r\n                positionmatrix[12] = (positionmatrix[12] * (2 / plane.w)) - 1;\r\n                positionmatrix[13] = -(positionmatrix[13] * (2 / plane.h)) + 1;\r\n                gl.uniformMatrix4fv(this.matrixLocation, false, positionmatrix);\r\n                if (this.textureMatrixLocation != null) {\r\n                    let texMatrix = _matrices__WEBPACK_IMPORTED_MODULE_1__[\"default\"].orthographic(-1, 1, 1, -1, -1, 1);\r\n                    gl.uniformMatrix4fv(this.textureMatrixLocation, false, texMatrix);\r\n                }\r\n            }\r\n        ];\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///../../engine/source/render/shaders/reverser.ts?\n}");

/***/ },

/***/ "../../engine/source/render/shaders/template.ts"
/*!******************************************************!*\
  !*** ../../engine/source/render/shaders/template.ts ***!
  \******************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Template)\n/* harmony export */ });\nclass Template {\r\n    constructor() {\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///../../engine/source/render/shaders/template.ts?\n}");

/***/ },

/***/ "../../engine/source/render/shaders/whitetransparent.ts"
/*!**************************************************************!*\
  !*** ../../engine/source/render/shaders/whitetransparent.ts ***!
  \**************************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WhiteTransparent: () => (/* binding */ WhiteTransparent)\n/* harmony export */ });\n/* harmony import */ var _matrices__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./matrices */ \"../../engine/source/render/shaders/matrices.ts\");\n/* harmony import */ var _template__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./template */ \"../../engine/source/render/shaders/template.ts\");\n\r\n\r\nclass WhiteTransparent extends _template__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = \"whitetransparent\";\r\n        // public texture : WebGLUniformLocation;\r\n        this.second = [\r\n            () => { }\r\n        ];\r\n        this.first = [\r\n            (ctx) => {\r\n                let gl = ctx;\r\n                let aVertexPosition = gl.getAttribLocation(this.program, \"aVertexPosition\");\r\n                gl.enableVertexAttribArray(aVertexPosition);\r\n                gl.vertexAttribPointer(aVertexPosition, 2, gl.FLOAT, false, 0, 0);\r\n                let texCoordLocation = gl.getAttribLocation(this.program, \"texcoordLocation\");\r\n                gl.enableVertexAttribArray(texCoordLocation);\r\n                gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);\r\n                this.matrixLocation = gl.getUniformLocation(this.program, \"matrixLocation\");\r\n                this.textureMatrixLocation = gl.getUniformLocation(this.program, \"textureMatrixLocation\");\r\n            },\r\n        ];\r\n        this.passes = [\r\n            (ctx, cmp, plane, extraarguments) => {\r\n                let gl = ctx;\r\n                let positionmatrix = new Float32Array([cmp.rprops.dstrect.w, 0, 0, 0,\r\n                    0, cmp.rprops.dstrect.h, 0, 0,\r\n                    0, 0, 1, 0,\r\n                    cmp.rprops.dstrect.x, plane.h - cmp.rprops.dstrect.y - cmp.rprops.dstrect.h, 0, 1]);\r\n                positionmatrix[0] *= 2 / plane.w;\r\n                positionmatrix[1] *= 2 / plane.w;\r\n                positionmatrix[4] *= -2 / plane.h;\r\n                positionmatrix[5] *= -2 / plane.h;\r\n                positionmatrix[12] = (positionmatrix[12] * (2 / plane.w)) - 1;\r\n                positionmatrix[13] = -(positionmatrix[13] * (2 / plane.h)) + 1;\r\n                gl.uniformMatrix4fv(this.matrixLocation, false, positionmatrix);\r\n                if (this.textureMatrixLocation != null) {\r\n                    let texMatrix = _matrices__WEBPACK_IMPORTED_MODULE_0__[\"default\"].orthographic(-1, 1, -1, 1, -1, 1);\r\n                    texMatrix = _matrices__WEBPACK_IMPORTED_MODULE_0__[\"default\"].translate(texMatrix, 0, 1, 0);\r\n                    if (cmp.rprops.flip.flipx && cmp.rprops.flip.flipy) {\r\n                    }\r\n                    else if (cmp.rprops.flip.flipx) {\r\n                        texMatrix = _matrices__WEBPACK_IMPORTED_MODULE_0__[\"default\"].orthographic(1, -1, -1, 1, -1, 1);\r\n                        texMatrix = _matrices__WEBPACK_IMPORTED_MODULE_0__[\"default\"].translate(texMatrix, -1, 1, 0);\r\n                    }\r\n                    else if (cmp.rprops.flip.flipy) {\r\n                    }\r\n                    gl.uniformMatrix4fv(this.textureMatrixLocation, false, texMatrix);\r\n                }\r\n            }\r\n        ];\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///../../engine/source/render/shaders/whitetransparent.ts?\n}");

/***/ },

/***/ "../../engine/source/render/textures.ts"
/*!**********************************************!*\
  !*** ../../engine/source/render/textures.ts ***!
  \**********************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Textures)\n/* harmony export */ });\n/* harmony import */ var _render__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_render */ \"../../engine/source/render/_render.ts\");\n\r\nclass Textures extends _render__WEBPACK_IMPORTED_MODULE_0__.Render.Info {\r\n    static createTexture(glContext, img) {\r\n        let gl = glContext.gl;\r\n        let tex = Textures.createTexToBlitOn(glContext, img.width, img.height);\r\n        gl.bindTexture(gl.TEXTURE_2D, tex);\r\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);\r\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\r\n        return tex;\r\n    }\r\n    static createSprite(glContext, file, from, bounds) {\r\n        let gl = glContext.gl;\r\n        const framebuffer = gl.createFramebuffer();\r\n        let spr = Textures.createTexToBlitOn(glContext, bounds.w, bounds.h);\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\r\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, from, 0);\r\n        gl.bindTexture(gl.TEXTURE_2D, spr);\r\n        gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, bounds.x, bounds.y, bounds.w, bounds.h);\r\n        gl.deleteFramebuffer(framebuffer);\r\n        return spr;\r\n    }\r\n    static createTexToBlitOn(glContext, width, height) {\r\n        let gl = glContext.gl;\r\n        const targetTexture = gl.createTexture();\r\n        gl.bindTexture(gl.TEXTURE_2D, targetTexture);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n        return targetTexture;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///../../engine/source/render/textures.ts?\n}");

/***/ },

/***/ "../../engine/source/systems/_system.ts"
/*!**********************************************!*\
  !*** ../../engine/source/systems/_system.ts ***!
  \**********************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   System: () => (/* binding */ System)\n/* harmony export */ });\nclass System {\r\n    constructor(priority = false) {\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///../../engine/source/systems/_system.ts?\n}");

/***/ },

/***/ "../../engine/source/systems/camera.ts"
/*!*********************************************!*\
  !*** ../../engine/source/systems/camera.ts ***!
  \*********************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Camera)\n/* harmony export */ });\n/* harmony import */ var _system__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_system */ \"../../engine/source/systems/_system.ts\");\n/* harmony import */ var _cameraman__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cameraman */ \"../../engine/source/systems/cameraman.ts\");\n\r\n\r\nclass Camera extends _system__WEBPACK_IMPORTED_MODULE_0__.System {\r\n    constructor(size, bounds) {\r\n        super();\r\n        this.scale = { x: 1, y: 1 };\r\n        this.viewport = { x: 0, y: 0, w: size.w, h: size.h };\r\n        this.bounds = bounds;\r\n        this.cameraman = new _cameraman__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this);\r\n    }\r\n    refresh() {\r\n        this.viewport.x =\r\n            this.cameraman.actor.pos.x - this.viewport.w / 2 + this.cameraman.actor.hitbox.w / 2 + this.cameraman.actor.hitbox.x > this.bounds.x\r\n                ? (this.cameraman.actor.pos.x + this.viewport.w / 2 + this.cameraman.actor.hitbox.w / 2 + this.cameraman.actor.hitbox.x > this.bounds.w\r\n                    ? this.bounds.w - this.viewport.w\r\n                    : Math.floor(this.cameraman.actor.pos.x - this.viewport.w / 2 + this.cameraman.actor.hitbox.w / 2 + this.cameraman.actor.hitbox.x))\r\n                : this.bounds.x;\r\n        this.viewport.y =\r\n            this.cameraman.actor.pos.y - this.viewport.h / 2 + this.cameraman.actor.hitbox.h / 2 + this.cameraman.actor.hitbox.y > this.bounds.y\r\n                ? (this.cameraman.actor.pos.y + this.viewport.h / 2 + this.cameraman.actor.hitbox.h / 2 + this.cameraman.actor.hitbox.y > this.bounds.h\r\n                    ? this.bounds.h - this.viewport.h\r\n                    : Math.floor(this.cameraman.actor.pos.y - this.viewport.h / 2 + this.cameraman.actor.hitbox.h / 2 + this.cameraman.actor.hitbox.y))\r\n                : this.bounds.y;\r\n    }\r\n    setBounds(bounds) {\r\n        this.bounds = bounds;\r\n    }\r\n    // old and may not work\r\n    worldToScreen(actor) {\r\n        return { x: actor.pos.x - this.viewport.x, y: actor.pos.y - this.viewport.y };\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///../../engine/source/systems/camera.ts?\n}");

/***/ },

/***/ "../../engine/source/systems/cameraman.ts"
/*!************************************************!*\
  !*** ../../engine/source/systems/cameraman.ts ***!
  \************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Cameraman)\n/* harmony export */ });\n/* harmony import */ var _system__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_system */ \"../../engine/source/systems/_system.ts\");\n/* harmony import */ var _alacrity_bodies__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../alacrity/_bodies */ \"../../engine/source/alacrity/_bodies.ts\");\n/* harmony import */ var _alacrity_time__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../alacrity/time */ \"../../engine/source/alacrity/time.ts\");\n\r\n\r\n\r\nvar Actions;\r\n(function (Actions) {\r\n    Actions[Actions[\"idle\"] = 0] = \"idle\";\r\n    Actions[Actions[\"pan\"] = 1] = \"pan\";\r\n    Actions[Actions[\"zoom\"] = 2] = \"zoom\";\r\n})(Actions || (Actions = {}));\r\nclass Cameraman extends _system__WEBPACK_IMPORTED_MODULE_0__.System {\r\n    constructor(camera) {\r\n        super(true);\r\n        this.action = Actions.idle;\r\n        this.callback = () => { };\r\n        this.pan = []; //from, distance\r\n        this.zoom = []; //from, distance\r\n        this.freemovement = new _alacrity_bodies__WEBPACK_IMPORTED_MODULE_1__.Bodies.Existence();\r\n        this.camera = camera;\r\n    }\r\n    refresh() {\r\n        if (this.action == Actions.idle)\r\n            return;\r\n        if (this.action == Actions.pan) {\r\n            while (this.actor.triggers.length > 0) {\r\n                let trig = this.actor.triggers.pop() || { name: '' };\r\n                if (trig.name == 'pan') {\r\n                    if (trig.state == 'active') {\r\n                        this.actor.pos.x = this.pan[0].x + ((this.actor.timeouts[0].getTimeoutTicks() / this.actor.timeouts[0].ms[0]) * this.pan[1].x);\r\n                        this.actor.pos.y = this.pan[0].y + ((this.actor.timeouts[0].getTimeoutTicks() / this.actor.timeouts[0].ms[0]) * this.pan[1].y);\r\n                        console.log(this.actor.pos);\r\n                    }\r\n                    if (trig.state == 'triggered') {\r\n                        this.actor.timeouts = [];\r\n                        this.action = Actions.idle;\r\n                        this.callback();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (this.action == Actions.zoom) {\r\n            while (this.actor.triggers.length > 0) {\r\n                let trig = this.actor.triggers.pop() || { name: '' };\r\n                if (trig.name == 'zoom') {\r\n                    if (trig.state == 'active') {\r\n                        this.actor.pos.x = this.pan[0].x + ((this.actor.timeouts[0].getTimeoutTicks() / this.actor.timeouts[0].ms[0]) * this.pan[1].x);\r\n                        this.actor.pos.y = this.pan[0].y + ((this.actor.timeouts[0].getTimeoutTicks() / this.actor.timeouts[0].ms[0]) * this.pan[1].y);\r\n                        this.camera.scale.x = this.zoom[0].x + ((this.actor.timeouts[0].getTimeoutTicks() / this.actor.timeouts[0].ms[0]) * this.zoom[1].x);\r\n                        this.camera.scale.y = this.zoom[0].y + ((this.actor.timeouts[0].getTimeoutTicks() / this.actor.timeouts[0].ms[0]) * this.zoom[1].y);\r\n                    }\r\n                    if (trig.state == 'triggered') {\r\n                        this.actor.timeouts = [];\r\n                        this.action = Actions.idle;\r\n                        this.callback();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    panCamera(from, to, duration, callback = () => { }) {\r\n        this.actor = this.freemovement;\r\n        this.actor.pos.x = from.x;\r\n        this.actor.pos.y = from.y;\r\n        this.actor.timeouts = [new _alacrity_time__WEBPACK_IMPORTED_MODULE_2__.Time.Timeout([duration], 'pan')];\r\n        this.pan[0] = from;\r\n        this.pan[1] = { x: to.x - from.x, y: to.y - from.y };\r\n        this.action = Actions.pan;\r\n        this.callback = callback;\r\n    }\r\n    zoomCamera(from, to, zoom, duration, callback = () => { }) {\r\n        this.actor = this.freemovement;\r\n        this.actor.pos.x = from.x;\r\n        this.actor.pos.y = from.y;\r\n        this.actor.timeouts = [new _alacrity_time__WEBPACK_IMPORTED_MODULE_2__.Time.Timeout([duration], 'zoom')];\r\n        this.pan[0] = from;\r\n        this.pan[1] = { x: to.x - from.x, y: to.y - from.y };\r\n        this.zoom[0] = { x: this.camera.scale.x, y: this.camera.scale.y };\r\n        this.zoom[1] = { x: zoom.x - this.camera.scale.x, y: zoom.y - this.camera.scale.y };\r\n        this.action = Actions.zoom;\r\n        this.callback = callback;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///../../engine/source/systems/cameraman.ts?\n}");

/***/ },

/***/ "../../engine/source/systems/keyboard.ts"
/*!***********************************************!*\
  !*** ../../engine/source/systems/keyboard.ts ***!
  \***********************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Keyboard: () => (/* binding */ Keyboard)\n/* harmony export */ });\n// import System from \"./_system\"\r\nclass Keyboard {\r\n    constructor() {\r\n        if (!Keyboard.init) {\r\n            document.addEventListener(\"keydown\", (event) => {\r\n                if (!event.repeat)\r\n                    Keyboard.keys[event.key] = 1;\r\n            });\r\n            document.addEventListener(\"keyup\", (event) => {\r\n                Keyboard.keys[event.key] = -1;\r\n            });\r\n        }\r\n        Keyboard.init = true;\r\n    }\r\n    static refresh() {\r\n        for (let k in Keyboard.keys) {\r\n            Keyboard.keys[k] = Keyboard.keys[k] < 0 ?\r\n                0 : Keyboard.keys[k] > 0 ? 2 : 0;\r\n        }\r\n    }\r\n}\r\nKeyboard.init = false;\r\nKeyboard.keys = {};\r\n\n\n//# sourceURL=webpack:///../../engine/source/systems/keyboard.ts?\n}");

/***/ },

/***/ "../../engine/source/systems/physics.ts"
/*!**********************************************!*\
  !*** ../../engine/source/systems/physics.ts ***!
  \**********************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Physics: () => (/* binding */ Physics)\n/* harmony export */ });\n/* harmony import */ var _system__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_system */ \"../../engine/source/systems/_system.ts\");\n/* harmony import */ var _physics_states__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../physics/states */ \"../../engine/source/physics/states.ts\");\n\r\n\r\nclass Physics extends _system__WEBPACK_IMPORTED_MODULE_0__.System {\r\n    constructor() {\r\n        super();\r\n        this.collisionpool = [];\r\n        Physics.physicspool.push(this);\r\n    }\r\n    refresh() {\r\n        for (let phys of Physics.physicspool) {\r\n            phys.collisionpool = phys.collisionpool.filter((a) => (!a.deleteMe));\r\n            let all = phys.collisionpool.filter((a) => (a.self != null) || a.self == null);\r\n            for (let item of all) {\r\n                if (item.self)\r\n                    item.self.activeeffects = [_physics_states__WEBPACK_IMPORTED_MODULE_1__.CollideTypes.none, _physics_states__WEBPACK_IMPORTED_MODULE_1__.CollideTypes.none, _physics_states__WEBPACK_IMPORTED_MODULE_1__.CollideTypes.none, _physics_states__WEBPACK_IMPORTED_MODULE_1__.CollideTypes.none];\r\n            }\r\n            all.forEach((element) => {\r\n                let totest = new Set(all.filter((a) => ((a.from & element.cwith) && a.self)).map((a) => a.self));\r\n                if (element.self)\r\n                    totest.delete(element.self);\r\n                element.update(totest);\r\n            });\r\n        }\r\n    }\r\n    addCollisionTo(self, collision) {\r\n        this.collisionpool.push(collision);\r\n        if (self != null) {\r\n            self.collisions.push(collision);\r\n            collision.self = self;\r\n        }\r\n        return collision;\r\n    }\r\n}\r\nPhysics.physicspool = [];\r\n\n\n//# sourceURL=webpack:///../../engine/source/systems/physics.ts?\n}");

/***/ },

/***/ "../../engine/source/systems/touch.ts"
/*!********************************************!*\
  !*** ../../engine/source/systems/touch.ts ***!
  \********************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Touch: () => (/* binding */ Touch)\n/* harmony export */ });\n/* harmony import */ var _alacrity_time__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../alacrity/time */ \"../../engine/source/alacrity/time.ts\");\n\r\nclass Touch {\r\n    constructor() {\r\n        if (!Touch.init) {\r\n            let html = document.getElementById(\"canvas\");\r\n            Touch.view = { w: html.clientWidth, h: html.clientHeight };\r\n            for (let i = 0; i < 4; i++) {\r\n                Touch.touches.push({\r\n                    state: 0,\r\n                    pos: { x: 0, y: 0 },\r\n                    start: { x: 0, y: 0 },\r\n                    timer: new _alacrity_time__WEBPACK_IMPORTED_MODULE_0__.Time.Timeout([Infinity], \"time\")\r\n                });\r\n            }\r\n            document.addEventListener('touchstart', (event) => {\r\n                for (let i = 0; i < Math.min(event.changedTouches.length, 4); i++) {\r\n                    Touch.touches[event.changedTouches[i].identifier] = {\r\n                        state: 1,\r\n                        pos: { x: event.changedTouches[i].clientX,\r\n                            y: event.changedTouches[i].clientY },\r\n                        start: { x: event.changedTouches[i].clientX,\r\n                            y: event.changedTouches[i].clientY },\r\n                        timer: new _alacrity_time__WEBPACK_IMPORTED_MODULE_0__.Time.Timeout([Infinity], \"time\")\r\n                    };\r\n                }\r\n            });\r\n            document.addEventListener('touchend', (event) => {\r\n                event.preventDefault();\r\n                for (let i = 0; i < event.changedTouches.length; i++) {\r\n                    Touch.touches[event.changedTouches[i].identifier].state = -1;\r\n                }\r\n                Touch.clicked = [];\r\n            });\r\n            document.addEventListener('touchmove', (event) => {\r\n                event.preventDefault();\r\n                for (let i = 0; i < event.changedTouches.length; i++) {\r\n                    Touch.touches[event.changedTouches[i].identifier].pos =\r\n                        { x: event.changedTouches[i].clientX, y: event.changedTouches[i].clientY };\r\n                }\r\n            });\r\n        }\r\n        Touch.init = true;\r\n    }\r\n    static refresh() {\r\n        for (let t in Touch.touches) {\r\n            Touch.touches[t].state = Touch.touches[t].state < 0 ?\r\n                0 : Touch.touches[t].state > 0 ? 2 : 0;\r\n        }\r\n        for (let c in Touch.clickables) {\r\n            Touch.clickables[c] = Touch.clickables[c] < 0 ?\r\n                0 : Touch.clickables[c] > 0 ? 2 : 0;\r\n        }\r\n        for (let i = 0; i < Touch.touches.length; i++) {\r\n            let h = Touch.touches[i];\r\n            if (h && h.state == 0) {\r\n                for (let j of Touch.ckables) {\r\n                    if (i == j.ownertouch) {\r\n                        Touch.clickables[j.name] = -1;\r\n                        j.ownertouch = -1;\r\n                    }\r\n                }\r\n            }\r\n            if (h && h.state > 0) {\r\n                for (let j of Touch.ckables) {\r\n                    if (Touch.inBounds(h.pos.x, h.pos.y, j.bounds)) {\r\n                        if (Touch.clickables[j.name] <= 0) {\r\n                            Touch.clickables[j.name] = 1;\r\n                            j.ownertouch = i;\r\n                        }\r\n                        j.callback();\r\n                    }\r\n                    else if (Touch.clickables[j.name] > 0) {\r\n                        Touch.clickables[j.name] = -1;\r\n                        j.ownertouch = -1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    static addButton(name, bounds, callback = () => { }) {\r\n        Touch.ckables.push({ name: name, bounds: bounds, callback: callback, ownertouch: -1 });\r\n        console.log(bounds);\r\n        Touch.clickables[name] = 0;\r\n    }\r\n    static registerUIElement(name, element) {\r\n    }\r\n    static inBounds(x, y, bounds) {\r\n        return x > bounds.x &&\r\n            x < bounds.x + bounds.w &&\r\n            y > bounds.y &&\r\n            y < bounds.y + bounds.h;\r\n    }\r\n}\r\nTouch.clicked = [];\r\nTouch.clickables = {};\r\nTouch.ckables = [];\r\nTouch.touches = [];\r\nTouch.init = false;\r\n\n\n//# sourceURL=webpack:///../../engine/source/systems/touch.ts?\n}");

/***/ },

/***/ "../../engine/source/systems/window.ts"
/*!*********************************************!*\
  !*** ../../engine/source/systems/window.ts ***!
  \*********************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Window: () => (/* binding */ Window)\n/* harmony export */ });\n/* harmony import */ var _render_composite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../render/composite */ \"../../engine/source/render/composite.ts\");\n\r\nclass Window {\r\n    /**\r\n     * source : Render.GLContext\r\n     * target : HTMLCanvasElement (2D canvas or same as source)\r\n     */\r\n    constructor(source, target = null) {\r\n        this.source = source;\r\n        this.target = target;\r\n        Window.windows.push(this);\r\n    }\r\n    static refresh() {\r\n        Window.windows.forEach((w) => w.update());\r\n    }\r\n    update() {\r\n        this.frame.setDirty();\r\n        this.frame.compose();\r\n        if (this.target != null) {\r\n        }\r\n        else {\r\n            let focus = _render_composite__WEBPACK_IMPORTED_MODULE_0__.Composite.Frame.createFocus(this.frame.frame);\r\n            var gl = this.source.gl;\r\n            gl.clearColor(1, 1, 1, 1);\r\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n            gl.clear(gl.COLOR_BUFFER_BIT);\r\n            gl.bindTexture(gl.TEXTURE_2D, this.frame.texture);\r\n            this.frame.shadercontext.passShader(this.frame, { x: focus.x, y: focus.y, w: gl.canvas.width, h: gl.canvas.height });\r\n            gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n        }\r\n    }\r\n}\r\nWindow.windows = [];\r\n\n\n//# sourceURL=webpack:///../../engine/source/systems/window.ts?\n}");

/***/ },

/***/ "./asset-performance.ts"
/*!******************************!*\
  !*** ./asset-performance.ts ***!
  \******************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AssetPerformanceTests: () => (/* binding */ AssetPerformanceTests)\n/* harmony export */ });\n/* harmony import */ var _benchmark__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./benchmark */ \"./benchmark.ts\");\n/* harmony import */ var _engine_source__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../engine/source */ \"../../engine/source/index.ts\");\n/* harmony import */ var _engine_source_render_textures__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../engine/source/render/textures */ \"../../engine/source/render/textures.ts\");\n/**\r\n * Asset loading performance tests for TEWOU engine\r\n * Tests image loading, texture creation, audio loading, and text file loading\r\n */\r\n\r\n\r\n\r\nclass AssetPerformanceTests {\r\n    constructor() {\r\n        this.benchmark = new _benchmark__WEBPACK_IMPORTED_MODULE_0__.PerformanceBenchmark();\r\n        this.memory = new _benchmark__WEBPACK_IMPORTED_MODULE_0__.MemoryProfiler();\r\n        this.setupCanvas();\r\n    }\r\n    setupCanvas() {\r\n        this.canvas = document.createElement('canvas');\r\n        this.canvas.width = 800;\r\n        this.canvas.height = 600;\r\n        this.glContext = new _engine_source__WEBPACK_IMPORTED_MODULE_1__.Render.GLContext(this.canvas, '800', '600');\r\n    }\r\n    /**\r\n     * Create test image data\r\n     */\r\n    createTestImageData(width, height) {\r\n        const canvas = document.createElement('canvas');\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n        const ctx = canvas.getContext('2d');\r\n        const imageData = ctx.createImageData(width, height);\r\n        for (let i = 0; i < imageData.data.length; i += 4) {\r\n            imageData.data[i] = Math.random() * 255;\r\n            imageData.data[i + 1] = Math.random() * 255;\r\n            imageData.data[i + 2] = Math.random() * 255;\r\n            imageData.data[i + 3] = 255;\r\n        }\r\n        ctx.putImageData(imageData, 0, 0);\r\n        const img = new Image();\r\n        img.src = canvas.toDataURL();\r\n        return img;\r\n    }\r\n    /**\r\n     * Test texture creation performance with different sizes\r\n     */\r\n    async testTextureCreation() {\r\n        console.log('\\n=== Texture Creation Performance ===\\n');\r\n        const textureSizes = [\r\n            { w: 64, h: 64 },\r\n            { w: 128, h: 128 },\r\n            { w: 256, h: 256 },\r\n            { w: 512, h: 512 },\r\n            { w: 1024, h: 1024 }\r\n        ];\r\n        for (const size of textureSizes) {\r\n            const img = this.createTestImageData(size.w, size.h);\r\n            await new Promise(resolve => {\r\n                img.onload = resolve;\r\n            });\r\n            this.memory.takeSnapshot(`before-tex-${size.w}x${size.h}`);\r\n            await this.benchmark.benchmark(`Create ${size.w}x${size.h} texture`, () => {\r\n                const tex = _engine_source_render_textures__WEBPACK_IMPORTED_MODULE_2__[\"default\"].createTexture(this.glContext, img);\r\n                this.glContext.gl.deleteTexture(tex);\r\n            }, 100);\r\n            this.memory.takeSnapshot(`after-tex-${size.w}x${size.h}`);\r\n            const memUsed = this.memory.compare(`before-tex-${size.w}x${size.h}`, `after-tex-${size.w}x${size.h}`);\r\n            console.log(`  Memory used: ${(memUsed / 1024 / 1024).toFixed(2)} MB`);\r\n        }\r\n    }\r\n    /**\r\n     * Test batch texture creation\r\n     */\r\n    async testBatchTextureCreation() {\r\n        console.log('\\n=== Batch Texture Creation Performance ===\\n');\r\n        const batchSizes = [10, 50, 100];\r\n        const textureSize = { w: 128, h: 128 };\r\n        for (const count of batchSizes) {\r\n            const images = [];\r\n            for (let i = 0; i < count; i++) {\r\n                const img = this.createTestImageData(textureSize.w, textureSize.h);\r\n                images.push(img);\r\n            }\r\n            await Promise.all(images.map(img => new Promise(resolve => {\r\n                img.onload = resolve;\r\n            })));\r\n            this.memory.takeSnapshot(`before-batch-${count}`);\r\n            await this.benchmark.benchmark(`Create ${count} textures (${textureSize.w}x${textureSize.h})`, () => {\r\n                const textures = [];\r\n                for (const img of images) {\r\n                    textures.push(_engine_source_render_textures__WEBPACK_IMPORTED_MODULE_2__[\"default\"].createTexture(this.glContext, img));\r\n                }\r\n                for (const tex of textures) {\r\n                    this.glContext.gl.deleteTexture(tex);\r\n                }\r\n            }, 10);\r\n            this.memory.takeSnapshot(`after-batch-${count}`);\r\n            const memUsed = this.memory.compare(`before-batch-${count}`, `after-batch-${count}`);\r\n            console.log(`  Memory used: ${(memUsed / 1024 / 1024).toFixed(2)} MB`);\r\n        }\r\n    }\r\n    /**\r\n     * Test texture upload to GPU\r\n     */\r\n    async testTextureUpload() {\r\n        console.log('\\n=== Texture Upload Performance ===\\n');\r\n        const textureSizes = [\r\n            { w: 128, h: 128 },\r\n            { w: 256, h: 256 },\r\n            { w: 512, h: 512 }\r\n        ];\r\n        for (const size of textureSizes) {\r\n            const img = this.createTestImageData(size.w, size.h);\r\n            await new Promise(resolve => {\r\n                img.onload = resolve;\r\n            });\r\n            await this.benchmark.benchmark(`Upload ${size.w}x${size.h} to GPU`, () => {\r\n                const tex = this.glContext.gl.createTexture();\r\n                this.glContext.gl.bindTexture(this.glContext.gl.TEXTURE_2D, tex);\r\n                this.glContext.gl.texImage2D(this.glContext.gl.TEXTURE_2D, 0, this.glContext.gl.RGBA, this.glContext.gl.RGBA, this.glContext.gl.UNSIGNED_BYTE, img);\r\n                this.glContext.gl.deleteTexture(tex);\r\n            }, 100);\r\n        }\r\n    }\r\n    /**\r\n     * Test different texture filtering modes\r\n     */\r\n    async testTextureFiltering() {\r\n        console.log('\\n=== Texture Filtering Performance ===\\n');\r\n        const img = this.createTestImageData(256, 256);\r\n        await new Promise(resolve => {\r\n            img.onload = resolve;\r\n        });\r\n        const filterModes = [\r\n            { name: 'NEAREST', min: 'NEAREST', mag: 'NEAREST' },\r\n            { name: 'LINEAR', min: 'LINEAR', mag: 'LINEAR' },\r\n            { name: 'MIPMAP_NEAREST', min: 'NEAREST_MIPMAP_NEAREST', mag: 'NEAREST' },\r\n            { name: 'MIPMAP_LINEAR', min: 'LINEAR_MIPMAP_LINEAR', mag: 'LINEAR' }\r\n        ];\r\n        for (const mode of filterModes) {\r\n            await this.benchmark.benchmark(`Create texture with ${mode.name} filtering`, () => {\r\n                const tex = this.glContext.gl.createTexture();\r\n                this.glContext.gl.bindTexture(this.glContext.gl.TEXTURE_2D, tex);\r\n                this.glContext.gl.texImage2D(this.glContext.gl.TEXTURE_2D, 0, this.glContext.gl.RGBA, this.glContext.gl.RGBA, this.glContext.gl.UNSIGNED_BYTE, img);\r\n                this.glContext.gl.texParameteri(this.glContext.gl.TEXTURE_2D, this.glContext.gl.TEXTURE_MIN_FILTER, this.glContext.gl[mode.min]);\r\n                this.glContext.gl.texParameteri(this.glContext.gl.TEXTURE_2D, this.glContext.gl.TEXTURE_MAG_FILTER, this.glContext.gl[mode.mag]);\r\n                if (mode.name.includes('MIPMAP')) {\r\n                    this.glContext.gl.generateMipmap(this.glContext.gl.TEXTURE_2D);\r\n                }\r\n                this.glContext.gl.deleteTexture(tex);\r\n            }, 50);\r\n        }\r\n    }\r\n    /**\r\n     * Test data URL image creation\r\n     */\r\n    async testDataUrlImages() {\r\n        console.log('\\n=== Data URL Image Performance ===\\n');\r\n        const sizes = [\r\n            { w: 64, h: 64 },\r\n            { w: 128, h: 128 },\r\n            { w: 256, h: 256 }\r\n        ];\r\n        for (const size of sizes) {\r\n            const canvas = document.createElement('canvas');\r\n            canvas.width = size.w;\r\n            canvas.height = size.h;\r\n            const ctx = canvas.getContext('2d');\r\n            const imageData = ctx.createImageData(size.w, size.h);\r\n            for (let i = 0; i < imageData.data.length; i += 4) {\r\n                imageData.data[i] = 255;\r\n                imageData.data[i + 1] = 0;\r\n                imageData.data[i + 2] = 0;\r\n                imageData.data[i + 3] = 255;\r\n            }\r\n            ctx.putImageData(imageData, 0, 0);\r\n            await this.benchmark.benchmark(`Create ${size.w}x${size.h} data URL`, () => {\r\n                canvas.toDataURL();\r\n            }, 100);\r\n            const dataUrl = canvas.toDataURL();\r\n            await this.benchmark.benchmarkAsync(`Load ${size.w}x${size.h} from data URL`, async () => {\r\n                const img = new Image();\r\n                img.src = dataUrl;\r\n                await img.decode();\r\n            }, 50);\r\n        }\r\n    }\r\n    /**\r\n     * Test canvas-to-texture pipeline\r\n     */\r\n    async testCanvasToTexture() {\r\n        console.log('\\n=== Canvas to Texture Pipeline ===\\n');\r\n        const sizes = [\r\n            { w: 128, h: 128 },\r\n            { w: 256, h: 256 },\r\n            { w: 512, h: 512 }\r\n        ];\r\n        for (const size of sizes) {\r\n            const canvas = document.createElement('canvas');\r\n            canvas.width = size.w;\r\n            canvas.height = size.h;\r\n            const ctx = canvas.getContext('2d');\r\n            ctx.fillStyle = 'red';\r\n            ctx.fillRect(0, 0, size.w, size.h);\r\n            await this.benchmark.benchmark(`Canvas (${size.w}x${size.h}) to texture`, () => {\r\n                const tex = this.glContext.gl.createTexture();\r\n                this.glContext.gl.bindTexture(this.glContext.gl.TEXTURE_2D, tex);\r\n                this.glContext.gl.texImage2D(this.glContext.gl.TEXTURE_2D, 0, this.glContext.gl.RGBA, this.glContext.gl.RGBA, this.glContext.gl.UNSIGNED_BYTE, canvas);\r\n                this.glContext.gl.deleteTexture(tex);\r\n            }, 100);\r\n        }\r\n    }\r\n    /**\r\n     * Test texture cache performance\r\n     */\r\n    async testTextureCaching() {\r\n        console.log('\\n=== Texture Caching Performance ===\\n');\r\n        const img = this.createTestImageData(256, 256);\r\n        await new Promise(resolve => {\r\n            img.onload = resolve;\r\n        });\r\n        const textureCache = new Map();\r\n        await this.benchmark.benchmark('Create texture without cache', () => {\r\n            const tex = _engine_source_render_textures__WEBPACK_IMPORTED_MODULE_2__[\"default\"].createTexture(this.glContext, img);\r\n            this.glContext.gl.deleteTexture(tex);\r\n        }, 200);\r\n        const cachedTex = _engine_source_render_textures__WEBPACK_IMPORTED_MODULE_2__[\"default\"].createTexture(this.glContext, img);\r\n        textureCache.set('test-texture', cachedTex);\r\n        await this.benchmark.benchmark('Retrieve texture from cache', () => {\r\n            const tex = textureCache.get('test-texture');\r\n        }, 1000);\r\n        this.glContext.gl.deleteTexture(cachedTex);\r\n    }\r\n    /**\r\n     * Test memory usage during asset loading\r\n     */\r\n    async testAssetLoadingMemory() {\r\n        console.log('\\n=== Asset Loading Memory Usage ===\\n');\r\n        this.memory.takeSnapshot('before-assets');\r\n        const textures = [];\r\n        for (let i = 0; i < 50; i++) {\r\n            const img = this.createTestImageData(128, 128);\r\n            await new Promise(resolve => {\r\n                img.onload = resolve;\r\n            });\r\n            textures.push(_engine_source_render_textures__WEBPACK_IMPORTED_MODULE_2__[\"default\"].createTexture(this.glContext, img));\r\n        }\r\n        this.memory.takeSnapshot('after-50-textures');\r\n        for (const tex of textures) {\r\n            this.glContext.gl.deleteTexture(tex);\r\n        }\r\n        this.memory.takeSnapshot('after-cleanup');\r\n        this.memory.printSnapshot('before-assets');\r\n        this.memory.printSnapshot('after-50-textures');\r\n        this.memory.printSnapshot('after-cleanup');\r\n        const memUsed = this.memory.compare('before-assets', 'after-50-textures');\r\n        console.log(`Total memory for 50 textures: ${(memUsed / 1024 / 1024).toFixed(2)} MB`);\r\n    }\r\n    /**\r\n     * Run all asset loading performance tests\r\n     */\r\n    async runAll() {\r\n        console.log('Starting Asset Loading Performance Tests...');\r\n        await this.testTextureCreation();\r\n        await this.testTextureUpload();\r\n        await this.testTextureFiltering();\r\n        await this.testBatchTextureCreation();\r\n        await this.testDataUrlImages();\r\n        await this.testCanvasToTexture();\r\n        await this.testTextureCaching();\r\n        await this.testAssetLoadingMemory();\r\n        this.benchmark.printResults();\r\n        console.log('\\nExporting results to JSON...');\r\n        const json = this.benchmark.exportJSON();\r\n        console.log(json);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./asset-performance.ts?\n}");

/***/ },

/***/ "./benchmark.ts"
/*!**********************!*\
  !*** ./benchmark.ts ***!
  \**********************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MemoryProfiler: () => (/* binding */ MemoryProfiler),\n/* harmony export */   PerformanceBenchmark: () => (/* binding */ PerformanceBenchmark)\n/* harmony export */ });\n/**\r\n * Performance benchmarking utilities for TEWOU engine\r\n */\r\nclass PerformanceBenchmark {\r\n    constructor() {\r\n        this.results = new Map();\r\n    }\r\n    /**\r\n     * Benchmark a synchronous function\r\n     */\r\n    async benchmark(name, fn, iterations = 1000) {\r\n        const samples = [];\r\n        // Warmup\r\n        for (let i = 0; i < 10; i++) {\r\n            fn();\r\n        }\r\n        // Actual benchmark\r\n        for (let i = 0; i < iterations; i++) {\r\n            const start = performance.now();\r\n            fn();\r\n            const end = performance.now();\r\n            samples.push(end - start);\r\n        }\r\n        const avgTime = samples.reduce((a, b) => a + b, 0) / samples.length;\r\n        const minTime = Math.min(...samples);\r\n        const maxTime = Math.max(...samples);\r\n        const opsPerSecond = 1000 / avgTime;\r\n        const result = {\r\n            name,\r\n            avgTime,\r\n            minTime,\r\n            maxTime,\r\n            iterations,\r\n            opsPerSecond,\r\n            samples\r\n        };\r\n        this.results.set(name, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Benchmark an asynchronous function\r\n     */\r\n    async benchmarkAsync(name, fn, iterations = 100) {\r\n        const samples = [];\r\n        // Warmup\r\n        for (let i = 0; i < 5; i++) {\r\n            await fn();\r\n        }\r\n        // Actual benchmark\r\n        for (let i = 0; i < iterations; i++) {\r\n            const start = performance.now();\r\n            await fn();\r\n            const end = performance.now();\r\n            samples.push(end - start);\r\n        }\r\n        const avgTime = samples.reduce((a, b) => a + b, 0) / samples.length;\r\n        const minTime = Math.min(...samples);\r\n        const maxTime = Math.max(...samples);\r\n        const opsPerSecond = 1000 / avgTime;\r\n        const result = {\r\n            name,\r\n            avgTime,\r\n            minTime,\r\n            maxTime,\r\n            iterations,\r\n            opsPerSecond,\r\n            samples\r\n        };\r\n        this.results.set(name, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Measure frame rate over a period of time\r\n     */\r\n    async measureFPS(renderFn, durationMs = 1000) {\r\n        const frames = [];\r\n        const startTime = performance.now();\r\n        let frameCount = 0;\r\n        let lastFrameTime = startTime;\r\n        return new Promise((resolve) => {\r\n            const measureFrame = () => {\r\n                const now = performance.now();\r\n                const deltaTime = now - lastFrameTime;\r\n                frames.push(deltaTime);\r\n                lastFrameTime = now;\r\n                frameCount++;\r\n                renderFn();\r\n                if (now - startTime < durationMs) {\r\n                    requestAnimationFrame(measureFrame);\r\n                }\r\n                else {\r\n                    const avgFrameTime = frames.reduce((a, b) => a + b, 0) / frames.length;\r\n                    const fps = 1000 / avgFrameTime;\r\n                    resolve({\r\n                        fps,\r\n                        frameTime: avgFrameTime,\r\n                        drawCalls: 0,\r\n                        entities: 0\r\n                    });\r\n                }\r\n            };\r\n            requestAnimationFrame(measureFrame);\r\n        });\r\n    }\r\n    /**\r\n     * Get all benchmark results\r\n     */\r\n    getResults() {\r\n        return this.results;\r\n    }\r\n    /**\r\n     * Print results to console\r\n     */\r\n    printResults() {\r\n        console.log('\\n=== Performance Benchmark Results ===\\n');\r\n        for (const [name, result] of this.results) {\r\n            console.log(`${name}:`);\r\n            console.log(`  Avg: ${result.avgTime.toFixed(3)}ms`);\r\n            console.log(`  Min: ${result.minTime.toFixed(3)}ms`);\r\n            console.log(`  Max: ${result.maxTime.toFixed(3)}ms`);\r\n            console.log(`  Ops/sec: ${result.opsPerSecond.toFixed(0)}`);\r\n            console.log('');\r\n        }\r\n    }\r\n    /**\r\n     * Export results as JSON\r\n     */\r\n    exportJSON() {\r\n        const resultsArray = Array.from(this.results.entries()).map(([name, result]) => ({\r\n            name,\r\n            avgTime: result.avgTime,\r\n            minTime: result.minTime,\r\n            maxTime: result.maxTime,\r\n            iterations: result.iterations,\r\n            opsPerSecond: result.opsPerSecond\r\n            // samples array excluded from export\r\n        }));\r\n        return JSON.stringify(resultsArray, null, 2);\r\n    }\r\n    /**\r\n     * Compare two benchmark results\r\n     */\r\n    compare(baseline, current) {\r\n        const baselineResult = this.results.get(baseline);\r\n        const currentResult = this.results.get(current);\r\n        if (!baselineResult || !currentResult) {\r\n            console.error('Cannot compare: one or both results not found');\r\n            return;\r\n        }\r\n        const diff = ((currentResult.avgTime - baselineResult.avgTime) / baselineResult.avgTime) * 100;\r\n        const improvement = diff < 0;\r\n        console.log(`\\nComparison: ${baseline} vs ${current}`);\r\n        console.log(`Difference: ${Math.abs(diff).toFixed(2)}% ${improvement ? 'faster' : 'slower'}`);\r\n    }\r\n}\r\n/**\r\n * Memory profiler utility\r\n */\r\nclass MemoryProfiler {\r\n    constructor() {\r\n        this.snapshots = new Map();\r\n    }\r\n    takeSnapshot(label) {\r\n        if (performance.memory) {\r\n            this.snapshots.set(label, performance.memory.usedJSHeapSize);\r\n        }\r\n    }\r\n    compare(before, after) {\r\n        const beforeMem = this.snapshots.get(before);\r\n        const afterMem = this.snapshots.get(after);\r\n        if (beforeMem === undefined || afterMem === undefined) {\r\n            console.error('Cannot compare: one or both snapshots not found');\r\n            return 0;\r\n        }\r\n        return afterMem - beforeMem;\r\n    }\r\n    printSnapshot(label) {\r\n        const mem = this.snapshots.get(label);\r\n        if (mem !== undefined) {\r\n            console.log(`${label}: ${(mem / 1024 / 1024).toFixed(2)} MB`);\r\n        }\r\n    }\r\n    getAllSnapshots() {\r\n        return this.snapshots;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./benchmark.ts?\n}");

/***/ },

/***/ "./index.ts"
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AssetPerformanceTests: () => (/* reexport safe */ _asset_performance__WEBPACK_IMPORTED_MODULE_3__.AssetPerformanceTests),\n/* harmony export */   ParserPerformanceTests: () => (/* reexport safe */ _parser_performance__WEBPACK_IMPORTED_MODULE_2__.ParserPerformanceTests),\n/* harmony export */   PerformanceTestRunner: () => (/* binding */ PerformanceTestRunner),\n/* harmony export */   PhysicsPerformanceTests: () => (/* reexport safe */ _physics_performance__WEBPACK_IMPORTED_MODULE_1__.PhysicsPerformanceTests),\n/* harmony export */   RenderPerformanceTests: () => (/* reexport safe */ _render_performance__WEBPACK_IMPORTED_MODULE_0__.RenderPerformanceTests)\n/* harmony export */ });\n/* harmony import */ var _render_performance__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./render-performance */ \"./render-performance.ts\");\n/* harmony import */ var _physics_performance__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./physics-performance */ \"./physics-performance.ts\");\n/* harmony import */ var _parser_performance__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parser-performance */ \"./parser-performance.ts\");\n/* harmony import */ var _asset_performance__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./asset-performance */ \"./asset-performance.ts\");\n/**\r\n * Main entry point for TEWOU engine performance tests\r\n * Run all tests or specific test suites\r\n */\r\n\r\n\r\n\r\n\r\nclass PerformanceTestRunner {\r\n    constructor() {\r\n        this.testSuites = [];\r\n        this.registerSuites();\r\n    }\r\n    registerSuites() {\r\n        this.testSuites.push({\r\n            name: 'Render',\r\n            run: async () => {\r\n                const tests = new _render_performance__WEBPACK_IMPORTED_MODULE_0__.RenderPerformanceTests();\r\n                await tests.runAll();\r\n            }\r\n        });\r\n        this.testSuites.push({\r\n            name: 'Physics',\r\n            run: async () => {\r\n                const tests = new _physics_performance__WEBPACK_IMPORTED_MODULE_1__.PhysicsPerformanceTests();\r\n                await tests.runAll();\r\n            }\r\n        });\r\n        this.testSuites.push({\r\n            name: 'Parser',\r\n            run: async () => {\r\n                const tests = new _parser_performance__WEBPACK_IMPORTED_MODULE_2__.ParserPerformanceTests();\r\n                await tests.runAll();\r\n            }\r\n        });\r\n        this.testSuites.push({\r\n            name: 'Asset',\r\n            run: async () => {\r\n                const tests = new _asset_performance__WEBPACK_IMPORTED_MODULE_3__.AssetPerformanceTests();\r\n                await tests.runAll();\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Run all test suites\r\n     */\r\n    async runAll() {\r\n        console.log('='.repeat(60));\r\n        console.log('TEWOU Engine Performance Test Suite');\r\n        console.log('='.repeat(60));\r\n        const startTime = performance.now();\r\n        for (const suite of this.testSuites) {\r\n            console.log(`\\n${'='.repeat(60)}`);\r\n            console.log(`Running ${suite.name} Performance Tests`);\r\n            console.log('='.repeat(60));\r\n            const suiteStartTime = performance.now();\r\n            await suite.run();\r\n            const suiteEndTime = performance.now();\r\n            console.log(`\\n${suite.name} tests completed in ${(suiteEndTime - suiteStartTime).toFixed(2)}ms`);\r\n        }\r\n        const endTime = performance.now();\r\n        console.log('\\n' + '='.repeat(60));\r\n        console.log(`All tests completed in ${((endTime - startTime) / 1000).toFixed(2)}s`);\r\n        console.log('='.repeat(60));\r\n    }\r\n    /**\r\n     * Run a specific test suite\r\n     */\r\n    async runSuite(suiteName) {\r\n        const suite = this.testSuites.find(s => s.name.toLowerCase() === suiteName.toLowerCase());\r\n        if (!suite) {\r\n            console.error(`Test suite \"${suiteName}\" not found`);\r\n            console.log('Available suites:', this.testSuites.map(s => s.name).join(', '));\r\n            return;\r\n        }\r\n        console.log('='.repeat(60));\r\n        console.log(`Running ${suite.name} Performance Tests`);\r\n        console.log('='.repeat(60));\r\n        const startTime = performance.now();\r\n        await suite.run();\r\n        const endTime = performance.now();\r\n        console.log(`\\n${suite.name} tests completed in ${(endTime - startTime).toFixed(2)}ms`);\r\n    }\r\n    /**\r\n     * List all available test suites\r\n     */\r\n    listSuites() {\r\n        console.log('Available test suites:');\r\n        for (const suite of this.testSuites) {\r\n            console.log(`  - ${suite.name}`);\r\n        }\r\n    }\r\n}\r\n\r\n\n\n//# sourceURL=webpack:///./index.ts?\n}");

/***/ },

/***/ "./parser-performance.ts"
/*!*******************************!*\
  !*** ./parser-performance.ts ***!
  \*******************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ParserPerformanceTests: () => (/* binding */ ParserPerformanceTests)\n/* harmony export */ });\n/* harmony import */ var _benchmark__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./benchmark */ \"./benchmark.ts\");\n/* harmony import */ var _engine_source__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../engine/source */ \"../../engine/source/index.ts\");\n/**\r\n * Parser performance tests for TEWOU engine\r\n * Tests Tiled map parser, GANI animation parser, and INI parser\r\n */\r\n\r\n\r\nclass ParserPerformanceTests {\r\n    constructor() {\r\n        this.benchmark = new _benchmark__WEBPACK_IMPORTED_MODULE_0__.PerformanceBenchmark();\r\n        this.memory = new _benchmark__WEBPACK_IMPORTED_MODULE_0__.MemoryProfiler();\r\n    }\r\n    /**\r\n     * Generate sample GANI animation data\r\n     */\r\n    generateGaniData(frameCount, partsPerFrame) {\r\n        let gani = `GANI0001\\nanimation\\n`;\r\n        for (let f = 0; f < frameCount; f++) {\r\n            gani += `SPRITE ${f}\\n`;\r\n            for (let p = 0; p < partsPerFrame; p++) {\r\n                gani += `  texture${p}.png ${p * 16} ${p * 16} 16 16 0 0\\n`;\r\n            }\r\n        }\r\n        return gani;\r\n    }\r\n    /**\r\n     * Generate sample INI data\r\n     */\r\n    generateIniData(sectionCount, keysPerSection) {\r\n        let ini = '';\r\n        for (let s = 0; s < sectionCount; s++) {\r\n            ini += `[Section${s}]\\n`;\r\n            for (let k = 0; k < keysPerSection; k++) {\r\n                ini += `key${k}=value${k}\\n`;\r\n            }\r\n            ini += '\\n';\r\n        }\r\n        return ini;\r\n    }\r\n    /**\r\n     * Generate sample JSON tilemap data\r\n     */\r\n    generateTiledData(width, height, layers) {\r\n        const tilemap = {\r\n            width,\r\n            height,\r\n            tilewidth: 16,\r\n            tileheight: 16,\r\n            layers: []\r\n        };\r\n        for (let l = 0; l < layers; l++) {\r\n            const data = [];\r\n            for (let i = 0; i < width * height; i++) {\r\n                data.push(Math.floor(Math.random() * 100));\r\n            }\r\n            tilemap.layers.push({\r\n                name: `Layer${l}`,\r\n                type: 'tilelayer',\r\n                width,\r\n                height,\r\n                data,\r\n                visible: true,\r\n                opacity: 1\r\n            });\r\n        }\r\n        return JSON.stringify(tilemap);\r\n    }\r\n    /**\r\n     * Test GANI animation parser performance\r\n     */\r\n    async testGaniParser() {\r\n        console.log('\\n=== GANI Parser Performance ===\\n');\r\n        const testCases = [\r\n            { frames: 10, parts: 5 },\r\n            { frames: 20, parts: 10 },\r\n            { frames: 50, parts: 10 },\r\n            { frames: 100, parts: 15 }\r\n        ];\r\n        for (const test of testCases) {\r\n            const ganiData = this.generateGaniData(test.frames, test.parts);\r\n            this.memory.takeSnapshot(`before-gani-${test.frames}f-${test.parts}p`);\r\n            await this.benchmark.benchmark(`Parse GANI (${test.frames} frames, ${test.parts} parts/frame)`, () => {\r\n                _engine_source__WEBPACK_IMPORTED_MODULE_1__.GaniParser.parse(ganiData);\r\n            }, 100);\r\n            this.memory.takeSnapshot(`after-gani-${test.frames}f-${test.parts}p`);\r\n            const memUsed = this.memory.compare(`before-gani-${test.frames}f-${test.parts}p`, `after-gani-${test.frames}f-${test.parts}p`);\r\n            console.log(`  Memory used: ${(memUsed / 1024).toFixed(2)} KB`);\r\n        }\r\n    }\r\n    /**\r\n     * Test INI parser performance\r\n     */\r\n    async testIniParser() {\r\n        console.log('\\n=== INI Parser Performance ===\\n');\r\n        const testCases = [\r\n            { sections: 5, keys: 10 },\r\n            { sections: 10, keys: 20 },\r\n            { sections: 20, keys: 30 },\r\n            { sections: 50, keys: 50 }\r\n        ];\r\n        for (const test of testCases) {\r\n            const iniData = this.generateIniData(test.sections, test.keys);\r\n            await this.benchmark.benchmark(`Parse INI (${test.sections} sections, ${test.keys} keys/section)`, () => {\r\n                _engine_source__WEBPACK_IMPORTED_MODULE_1__.IniParser.parse(iniData);\r\n            }, 500);\r\n        }\r\n    }\r\n    /**\r\n     * Test JSON parsing performance (for Tiled maps)\r\n     */\r\n    async testJsonParsing() {\r\n        console.log('\\n=== JSON/Tiled Parser Performance ===\\n');\r\n        const testCases = [\r\n            { width: 20, height: 20, layers: 1 },\r\n            { width: 40, height: 40, layers: 3 },\r\n            { width: 50, height: 50, layers: 5 },\r\n            { width: 100, height: 100, layers: 3 }\r\n        ];\r\n        for (const test of testCases) {\r\n            const tiledData = this.generateTiledData(test.width, test.height, test.layers);\r\n            this.memory.takeSnapshot(`before-tiled-${test.width}x${test.height}x${test.layers}`);\r\n            await this.benchmark.benchmark(`Parse Tiled JSON (${test.width}x${test.height}, ${test.layers} layers)`, () => {\r\n                JSON.parse(tiledData);\r\n            }, 200);\r\n            this.memory.takeSnapshot(`after-tiled-${test.width}x${test.height}x${test.layers}`);\r\n            const memUsed = this.memory.compare(`before-tiled-${test.width}x${test.height}x${test.layers}`, `after-tiled-${test.width}x${test.height}x${test.layers}`);\r\n            console.log(`  Memory used: ${(memUsed / 1024).toFixed(2)} KB`);\r\n        }\r\n    }\r\n    /**\r\n     * Test string parsing operations\r\n     */\r\n    async testStringOperations() {\r\n        console.log('\\n=== String Parsing Operations ===\\n');\r\n        const testString = this.generateGaniData(50, 10);\r\n        await this.benchmark.benchmark('String split by newline', () => {\r\n            testString.split('\\n');\r\n        }, 1000);\r\n        await this.benchmark.benchmark('String split and trim', () => {\r\n            testString.split('\\n').map(line => line.trim());\r\n        }, 1000);\r\n        await this.benchmark.benchmark('String match with regex', () => {\r\n            const regex = /SPRITE\\s+(\\d+)/g;\r\n            let match;\r\n            while ((match = regex.exec(testString)) !== null) {\r\n                const frameNum = match[1];\r\n            }\r\n        }, 1000);\r\n        await this.benchmark.benchmark('String indexOf operations', () => {\r\n            const lines = testString.split('\\n');\r\n            for (const line of lines) {\r\n                if (line.indexOf('SPRITE') !== -1) {\r\n                    const parts = line.split(' ');\r\n                }\r\n            }\r\n        }, 500);\r\n    }\r\n    /**\r\n     * Test number parsing performance\r\n     */\r\n    async testNumberParsing() {\r\n        console.log('\\n=== Number Parsing Performance ===\\n');\r\n        const numberStrings = Array.from({ length: 1000 }, (_, i) => `${Math.random() * 1000}`);\r\n        await this.benchmark.benchmark('parseInt on 1000 numbers', () => {\r\n            for (const str of numberStrings) {\r\n                parseInt(str);\r\n            }\r\n        }, 500);\r\n        await this.benchmark.benchmark('parseFloat on 1000 numbers', () => {\r\n            for (const str of numberStrings) {\r\n                parseFloat(str);\r\n            }\r\n        }, 500);\r\n        await this.benchmark.benchmark('Number() on 1000 numbers', () => {\r\n            for (const str of numberStrings) {\r\n                Number(str);\r\n            }\r\n        }, 500);\r\n        await this.benchmark.benchmark('Unary + on 1000 numbers', () => {\r\n            for (const str of numberStrings) {\r\n                +str;\r\n            }\r\n        }, 500);\r\n    }\r\n    /**\r\n     * Test CSV parsing performance\r\n     */\r\n    async testCsvParsing() {\r\n        console.log('\\n=== CSV Parsing Performance ===\\n');\r\n        const csvSizes = [\r\n            { rows: 10, cols: 10 },\r\n            { rows: 50, cols: 50 },\r\n            { rows: 100, cols: 100 },\r\n            { rows: 200, cols: 200 }\r\n        ];\r\n        for (const size of csvSizes) {\r\n            let csv = '';\r\n            for (let r = 0; r < size.rows; r++) {\r\n                const row = Array.from({ length: size.cols }, () => Math.floor(Math.random() * 100));\r\n                csv += row.join(',') + '\\n';\r\n            }\r\n            await this.benchmark.benchmark(`Parse CSV (${size.rows}x${size.cols})`, () => {\r\n                const rows = csv.split('\\n');\r\n                const data = [];\r\n                for (const row of rows) {\r\n                    if (row.trim()) {\r\n                        data.push(row.split(',').map(v => parseInt(v)));\r\n                    }\r\n                }\r\n            }, 100);\r\n        }\r\n    }\r\n    /**\r\n     * Test array building performance (common in parsers)\r\n     */\r\n    async testArrayBuilding() {\r\n        console.log('\\n=== Array Building Performance ===\\n');\r\n        const sizes = [100, 500, 1000, 5000];\r\n        for (const size of sizes) {\r\n            await this.benchmark.benchmark(`Build array with push (${size} items)`, () => {\r\n                const arr = [];\r\n                for (let i = 0; i < size; i++) {\r\n                    arr.push(i);\r\n                }\r\n            }, 500);\r\n            await this.benchmark.benchmark(`Build array with index (${size} items)`, () => {\r\n                const arr = [];\r\n                for (let i = 0; i < size; i++) {\r\n                    arr[i] = i;\r\n                }\r\n            }, 500);\r\n            await this.benchmark.benchmark(`Build array with map (${size} items)`, () => {\r\n                Array.from({ length: size }, (_, i) => i);\r\n            }, 500);\r\n        }\r\n    }\r\n    /**\r\n     * Run all parser performance tests\r\n     */\r\n    async runAll() {\r\n        console.log('Starting Parser Performance Tests...');\r\n        await this.testStringOperations();\r\n        await this.testNumberParsing();\r\n        await this.testArrayBuilding();\r\n        await this.testCsvParsing();\r\n        await this.testGaniParser();\r\n        await this.testIniParser();\r\n        await this.testJsonParsing();\r\n        this.benchmark.printResults();\r\n        console.log('\\nExporting results to JSON...');\r\n        const json = this.benchmark.exportJSON();\r\n        console.log(json);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./parser-performance.ts?\n}");

/***/ },

/***/ "./physics-performance.ts"
/*!********************************!*\
  !*** ./physics-performance.ts ***!
  \********************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PhysicsPerformanceTests: () => (/* binding */ PhysicsPerformanceTests)\n/* harmony export */ });\n/* harmony import */ var _benchmark__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./benchmark */ \"./benchmark.ts\");\n/* harmony import */ var _engine_source__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../engine/source */ \"../../engine/source/index.ts\");\n/**\r\n * Physics performance tests for TEWOU engine\r\n * Tests collision detection, entity updates, and physics simulation\r\n */\r\n\r\n\r\nclass PhysicsPerformanceTests {\r\n    constructor() {\r\n        this.benchmark = new _benchmark__WEBPACK_IMPORTED_MODULE_0__.PerformanceBenchmark();\r\n        this.memory = new _benchmark__WEBPACK_IMPORTED_MODULE_0__.MemoryProfiler();\r\n        this.setupCanvas();\r\n        this.physics = new _engine_source__WEBPACK_IMPORTED_MODULE_1__.Physics();\r\n    }\r\n    setupCanvas() {\r\n        this.canvas = document.createElement('canvas');\r\n        this.canvas.width = 800;\r\n        this.canvas.height = 600;\r\n        this.glContext = new _engine_source__WEBPACK_IMPORTED_MODULE_1__.Render.GLContext(this.canvas, '800', '600');\r\n        this.shaderContext = new _engine_source__WEBPACK_IMPORTED_MODULE_1__.ShaderLoader(this.glContext.gl, [new _engine_source__WEBPACK_IMPORTED_MODULE_1__.Normal()]);\r\n    }\r\n    /**\r\n     * Create a test entity\r\n     */\r\n    createTestEntity(x, y) {\r\n        const rect = new _engine_source__WEBPACK_IMPORTED_MODULE_1__.Composite.Rectangle(this.glContext, this.shaderContext, { x: 0, y: 0, w: 32, h: 32 }, { r: 1, g: 0, b: 0, a: 1 });\r\n        const entity = new _engine_source__WEBPACK_IMPORTED_MODULE_1__.Bodies.Embodiment(rect);\r\n        entity.pos = { x, y };\r\n        entity.hitbox = { x: 0, y: 0, w: 32, h: 32 };\r\n        return entity;\r\n    }\r\n    /**\r\n     * Test entity update performance with varying numbers of entities\r\n     */\r\n    async testEntityUpdates() {\r\n        console.log('\\n=== Entity Update Performance ===\\n');\r\n        const entityCounts = [10, 50, 100, 500, 1000];\r\n        for (const count of entityCounts) {\r\n            const entities = [];\r\n            for (let i = 0; i < count; i++) {\r\n                const x = Math.random() * 800;\r\n                const y = Math.random() * 600;\r\n                entities.push(this.createTestEntity(x, y));\r\n            }\r\n            await this.benchmark.benchmark(`Update ${count} entities`, () => {\r\n                for (let i = 0; i < entities.length; i++) {\r\n                    entities[i].update();\r\n                }\r\n            }, 500);\r\n            await this.benchmark.benchmark(`Finalize ${count} entities`, () => {\r\n                for (let i = 0; i < entities.length; i++) {\r\n                    entities[i].finalize();\r\n                }\r\n            }, 500);\r\n        }\r\n    }\r\n    /**\r\n     * Test collision grid performance\r\n     */\r\n    async testCollisionGrid() {\r\n        console.log('\\n=== Collision Grid Performance ===\\n');\r\n        const gridSizes = [\r\n            { w: 1000, h: 1000, resolution: 32 },\r\n            { w: 2000, h: 2000, resolution: 32 },\r\n            // { w: 4000, h: 4000, resolution: 32 },\r\n            { w: 5000, h: 5000, resolution: 32 }\r\n        ];\r\n        for (const size of gridSizes) {\r\n            const grid = [];\r\n            for (let y = 0; y < size.h; y++) {\r\n                grid[y] = [];\r\n                for (let x = 0; x < size.w; x++) {\r\n                    grid[y][x] = Math.random() > 0.7;\r\n                }\r\n            }\r\n            // Benchmark grid creation\r\n            await this.benchmark.benchmark(`Create collision grid ${size.w}x${size.h}`, () => {\r\n                new _engine_source__WEBPACK_IMPORTED_MODULE_1__.CollisionGrid(grid, size.resolution, _engine_source__WEBPACK_IMPORTED_MODULE_1__.C.CollideLayers.npc | _engine_source__WEBPACK_IMPORTED_MODULE_1__.C.CollideLayers.player, _engine_source__WEBPACK_IMPORTED_MODULE_1__.C.CollideTypes.block);\r\n            }, 100);\r\n            // Set up physics system with collision grid for other tests\r\n            const physics = new _engine_source__WEBPACK_IMPORTED_MODULE_1__.Physics();\r\n            const collisionGrid = new _engine_source__WEBPACK_IMPORTED_MODULE_1__.CollisionGrid(grid, size.resolution, _engine_source__WEBPACK_IMPORTED_MODULE_1__.C.CollideLayers.npc | _engine_source__WEBPACK_IMPORTED_MODULE_1__.C.CollideLayers.player, _engine_source__WEBPACK_IMPORTED_MODULE_1__.C.CollideTypes.block);\r\n            physics.collisionpool.push(collisionGrid);\r\n            // Create test entity and register it with collision system\r\n            const testEntity = this.createTestEntity(100, 100);\r\n            // Register entity as NPC so it's on the npc layer\r\n            const entityCollision = new _engine_source__WEBPACK_IMPORTED_MODULE_1__.NPCCollision(testEntity, _engine_source__WEBPACK_IMPORTED_MODULE_1__.C.CollideLayers.npc, // Entity is on npc layer\r\n            _engine_source__WEBPACK_IMPORTED_MODULE_1__.C.CollideLayers.grid, // Collides with grid\r\n            _engine_source__WEBPACK_IMPORTED_MODULE_1__.C.CollideTypes.block);\r\n            physics.collisionpool.push(entityCollision);\r\n            await this.benchmark.benchmark(`Check collision in ${size.w}x${size.h} grid`, () => {\r\n                collisionGrid.intersect(testEntity);\r\n            }, 1000);\r\n            await this.benchmark.benchmark(`Test wall collision in ${size.w}x${size.h} grid`, () => {\r\n                collisionGrid.testWall({ x: 100, y: 100 });\r\n            }, 1000);\r\n        }\r\n    }\r\n    /**\r\n     * Test physics system refresh with multiple entities\r\n     */\r\n    async testPhysicsRefresh() {\r\n        console.log('\\n=== Physics System Refresh Performance ===\\n');\r\n        const entityCounts = [10, 50, 100, 200, 500];\r\n        for (const count of entityCounts) {\r\n            const physics = new _engine_source__WEBPACK_IMPORTED_MODULE_1__.Physics();\r\n            const entities = [];\r\n            for (let i = 0; i < count; i++) {\r\n                const x = Math.random() * 800;\r\n                const y = Math.random() * 600;\r\n                entities.push(this.createTestEntity(x, y));\r\n            }\r\n            await this.benchmark.benchmark(`Physics refresh with ${count} entities`, () => {\r\n                physics.refresh();\r\n            }, 500);\r\n        }\r\n    }\r\n    /**\r\n     * Test entity movement vector reset\r\n     */\r\n    async testMovementReset() {\r\n        console.log('\\n=== Movement Vector Reset Performance ===\\n');\r\n        const entityCounts = [100, 500, 1000, 2000];\r\n        for (const count of entityCounts) {\r\n            const entities = [];\r\n            for (let i = 0; i < count; i++) {\r\n                entities.push(this.createTestEntity(i, i));\r\n            }\r\n            await this.benchmark.benchmark(`Reset movement for ${count} entities`, () => {\r\n                _engine_source__WEBPACK_IMPORTED_MODULE_1__.Bodies.Alacrity.resetAllMovements(entities);\r\n            }, 500);\r\n        }\r\n    }\r\n    /**\r\n     * Test timeout/trigger system performance\r\n     */\r\n    async testTimeoutSystem() {\r\n        console.log('\\n=== Timeout/Trigger System Performance ===\\n');\r\n        const timeoutCounts = [10, 50, 100, 200];\r\n        for (const count of timeoutCounts) {\r\n            const entity = this.createTestEntity(0, 0);\r\n            for (let i = 0; i < count; i++) {\r\n                entity.addTimeout([100, 200, 300], {\r\n                    triggered: () => { },\r\n                    active: () => { },\r\n                    // onLoop: () => {}\r\n                }, true, true);\r\n            }\r\n            await this.benchmark.benchmark(`Update entity with ${count} timeouts`, () => {\r\n                entity.update();\r\n            }, 500);\r\n        }\r\n    }\r\n    /**\r\n     * Test hitbox collision detection\r\n     */\r\n    async testHitboxCollision() {\r\n        console.log('\\n=== Hitbox Collision Detection ===\\n');\r\n        const checkCounts = [10, 50, 100];\r\n        for (const count of checkCounts) {\r\n            const physics = new _engine_source__WEBPACK_IMPORTED_MODULE_1__.Physics();\r\n            const entities = [];\r\n            // Create and register entities with collision\r\n            for (let i = 0; i < count; i++) {\r\n                const x = Math.random() * 800;\r\n                const y = Math.random() * 600;\r\n                const entity = this.createTestEntity(x, y);\r\n                entities.push(entity);\r\n                // Register each entity with collision system\r\n                const collision = new _engine_source__WEBPACK_IMPORTED_MODULE_1__.NPCCollision(entity, _engine_source__WEBPACK_IMPORTED_MODULE_1__.C.CollideLayers.npc, _engine_source__WEBPACK_IMPORTED_MODULE_1__.C.CollideLayers.npc, _engine_source__WEBPACK_IMPORTED_MODULE_1__.C.CollideTypes.block);\r\n                physics.collisionpool.push(collision);\r\n            }\r\n            // Create test entity and register it\r\n            const testEntity = this.createTestEntity(400, 300);\r\n            const testCollision = new _engine_source__WEBPACK_IMPORTED_MODULE_1__.NPCCollision(testEntity, _engine_source__WEBPACK_IMPORTED_MODULE_1__.C.CollideLayers.npc, _engine_source__WEBPACK_IMPORTED_MODULE_1__.C.CollideLayers.npc, _engine_source__WEBPACK_IMPORTED_MODULE_1__.C.CollideTypes.block);\r\n            physics.collisionpool.push(testCollision);\r\n            await this.benchmark.benchmark(`Physics collision check ${count} entities`, () => {\r\n                physics.refresh();\r\n            }, 100);\r\n            await this.benchmark.benchmark(`Manual AABB collision ${count} entities`, () => {\r\n                for (let i = 0; i < entities.length; i++) {\r\n                    const e = entities[i];\r\n                    const overlap = testEntity.pos.x < e.pos.x + e.hitbox.w &&\r\n                        testEntity.pos.x + testEntity.hitbox.w > e.pos.x &&\r\n                        testEntity.pos.y < e.pos.y + e.hitbox.h &&\r\n                        testEntity.pos.y + testEntity.hitbox.h > e.pos.y;\r\n                }\r\n            }, 100);\r\n        }\r\n    }\r\n    /**\r\n     * Test spatial partitioning efficiency\r\n     */\r\n    async testSpatialPartitioning() {\r\n        console.log('\\n=== Spatial Partitioning Performance ===\\n');\r\n        const gridSize = 64;\r\n        const worldSize = 1024;\r\n        const entityCount = 1000;\r\n        const cells = new Map();\r\n        const entities = [];\r\n        for (let i = 0; i < entityCount; i++) {\r\n            const x = Math.random() * worldSize;\r\n            const y = Math.random() * worldSize;\r\n            entities.push(this.createTestEntity(x, y));\r\n        }\r\n        await this.benchmark.benchmark(`Partition ${entityCount} entities into grid`, () => {\r\n            cells.clear();\r\n            for (const entity of entities) {\r\n                const cellX = Math.floor(entity.pos.x / gridSize);\r\n                const cellY = Math.floor(entity.pos.y / gridSize);\r\n                const key = `${cellX},${cellY}`;\r\n                if (!cells.has(key)) {\r\n                    cells.set(key, []);\r\n                }\r\n                cells.get(key).push(entity);\r\n            }\r\n        }, 200);\r\n        await this.benchmark.benchmark(`Query nearby entities in partitioned grid`, () => {\r\n            const queryX = 512;\r\n            const queryY = 512;\r\n            const cellX = Math.floor(queryX / gridSize);\r\n            const cellY = Math.floor(queryY / gridSize);\r\n            const nearby = [];\r\n            for (let dy = -1; dy <= 1; dy++) {\r\n                for (let dx = -1; dx <= 1; dx++) {\r\n                    const key = `${cellX + dx},${cellY + dy}`;\r\n                    const cellEntities = cells.get(key);\r\n                    if (cellEntities) {\r\n                        nearby.push(...cellEntities);\r\n                    }\r\n                }\r\n            }\r\n        }, 1000);\r\n    }\r\n    /**\r\n     * Test entity lifecycle performance\r\n     */\r\n    async testEntityLifecycle() {\r\n        console.log('\\n=== Entity Lifecycle Performance ===\\n');\r\n        this.memory.takeSnapshot('before-entities');\r\n        const createCounts = [100, 500, 1000];\r\n        for (const count of createCounts) {\r\n            await this.benchmark.benchmark(`Create ${count} entities`, () => {\r\n                const entities = [];\r\n                for (let i = 0; i < count; i++) {\r\n                    entities.push(this.createTestEntity(i, i));\r\n                }\r\n            }, 100);\r\n            this.memory.takeSnapshot(`after-${count}-entities`);\r\n            const entities = [];\r\n            for (let i = 0; i < count; i++) {\r\n                entities.push(this.createTestEntity(i, i));\r\n            }\r\n            await this.benchmark.benchmark(`Destroy ${count} entities`, () => {\r\n                for (const entity of entities) {\r\n                    entity.destroy();\r\n                }\r\n            }, 100);\r\n            await this.benchmark.benchmark(`Filter ${count} deleted entities`, () => {\r\n                const filtered = entities.filter((e) => !e.delete);\r\n            }, 100);\r\n        }\r\n        this.memory.printSnapshot('before-entities');\r\n        for (const count of createCounts) {\r\n            this.memory.printSnapshot(`after-${count}-entities`);\r\n        }\r\n    }\r\n    /**\r\n     * Run all physics performance tests\r\n     */\r\n    async runAll() {\r\n        console.log('Starting Physics Performance Tests...');\r\n        await this.testEntityUpdates();\r\n        await this.testMovementReset();\r\n        await this.testTimeoutSystem();\r\n        await this.testHitboxCollision();\r\n        // await this.testCollisionGrid();\r\n        await this.testSpatialPartitioning();\r\n        await this.testPhysicsRefresh();\r\n        await this.testEntityLifecycle();\r\n        this.benchmark.printResults();\r\n        console.log('\\nExporting results to JSON...');\r\n        const json = this.benchmark.exportJSON();\r\n        console.log(json);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./physics-performance.ts?\n}");

/***/ },

/***/ "./render-performance.ts"
/*!*******************************!*\
  !*** ./render-performance.ts ***!
  \*******************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RenderPerformanceTests: () => (/* binding */ RenderPerformanceTests)\n/* harmony export */ });\n/* harmony import */ var _benchmark__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./benchmark */ \"./benchmark.ts\");\n/* harmony import */ var _engine_source__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../engine/source */ \"../../engine/source/index.ts\");\n/**\r\n * Render performance tests for TEWOU engine\r\n * Tests rendering pipeline, compositing, and WebGL operations\r\n */\r\n\r\n\r\n/**\r\n * Simple test Fauna entity for performance testing\r\n */\r\nclass TestFauna extends _engine_source__WEBPACK_IMPORTED_MODULE_1__.Incarnations.Fauna {\r\n    constructor(glContext, shaderContext, pos) {\r\n        // Create a simple colored rectangle as the visual\r\n        const rect = new _engine_source__WEBPACK_IMPORTED_MODULE_1__.Composite.Rectangle(glContext, shaderContext, { x: 0, y: 0, w: 16, h: 16 }, { r: Math.floor(Math.random() * 255), g: Math.floor(Math.random() * 255), b: Math.floor(Math.random() * 255), a: 1 });\r\n        super(rect);\r\n        this.actions = {\r\n            idle: {\r\n                state: _engine_source__WEBPACK_IMPORTED_MODULE_1__.T.RunSwitch.running\r\n            }\r\n        };\r\n        this.action = \"idle\";\r\n        this.pos = pos;\r\n        this.hitbox = { x: 0, y: 0, w: 16, h: 16 };\r\n        this.speed = 0.5;\r\n        this.state = \"idle\";\r\n    }\r\n}\r\nclass RenderPerformanceTests {\r\n    constructor() {\r\n        this.benchmark = new _benchmark__WEBPACK_IMPORTED_MODULE_0__.PerformanceBenchmark();\r\n        this.memory = new _benchmark__WEBPACK_IMPORTED_MODULE_0__.MemoryProfiler();\r\n        this.setupCanvas();\r\n    }\r\n    setupCanvas() {\r\n        this.canvas = document.createElement('canvas');\r\n        this.canvas.width = 800;\r\n        this.canvas.height = 600;\r\n        this.glContext = new _engine_source__WEBPACK_IMPORTED_MODULE_1__.Render.GLContext(this.canvas, '800', '600');\r\n        this.shaderContext = new _engine_source__WEBPACK_IMPORTED_MODULE_1__.ShaderLoader(this.glContext.gl);\r\n    }\r\n    /**\r\n     * Test frame composition performance with varying number of layers\r\n     */\r\n    async testFrameComposition() {\r\n        await this.shaderContext.init();\r\n        console.log('\\n=== Frame Composition Performance ===\\n');\r\n        const layerCounts = [100, 500, 1000];\r\n        for (const count of layerCounts) {\r\n            const frames = [];\r\n            for (let i = 0; i < count; i++) {\r\n                const rect = new _engine_source__WEBPACK_IMPORTED_MODULE_1__.Composite.Rectangle(this.glContext, this.shaderContext, { x: i * 2, y: i * 2, w: 32, h: 32 }, { r: 1, g: 0, b: 0, a: 1 });\r\n                frames.push(rect);\r\n            }\r\n            const frame = new _engine_source__WEBPACK_IMPORTED_MODULE_1__.Composite.Frame(this.glContext, this.shaderContext, frames);\r\n            await this.benchmark.benchmark(`Compose ${count} layers`, () => {\r\n                frame.compose();\r\n            }, 500);\r\n            // Cleanup\r\n            for (let f of frames)\r\n                f.rprops.delete = true;\r\n            frame.rprops.delete = true;\r\n            // Allow GPU to clean up resources\r\n            await this.gcPause(100);\r\n        }\r\n    }\r\n    /**\r\n     * Test rendering performance at different resolutions\r\n     */\r\n    async testResolutionScaling() {\r\n        console.log('\\n=== Resolution Scaling Performance ===\\n');\r\n        const resolutions = [\r\n            { w: 640, h: 480, name: 'VGA' },\r\n            { w: 1280, h: 720, name: 'HD' },\r\n            { w: 1920, h: 1080, name: 'Full HD' }\r\n        ];\r\n        for (const res of resolutions) {\r\n            const testCanvas = document.createElement('canvas');\r\n            testCanvas.width = res.w;\r\n            testCanvas.height = res.h;\r\n            const glCtx = new _engine_source__WEBPACK_IMPORTED_MODULE_1__.Render.GLContext(testCanvas, res.w.toString(), res.h.toString());\r\n            const shaderCtx = new _engine_source__WEBPACK_IMPORTED_MODULE_1__.ShaderLoader(glCtx.gl, [new _engine_source__WEBPACK_IMPORTED_MODULE_1__.Normal()]);\r\n            const rect = new _engine_source__WEBPACK_IMPORTED_MODULE_1__.Composite.Rectangle(glCtx, shaderCtx, { x: 0, y: 0, w: res.w, h: res.h }, { r: 0.5, g: 0.5, b: 0.5, a: 1 });\r\n            const frame = new _engine_source__WEBPACK_IMPORTED_MODULE_1__.Composite.Frame(glCtx, shaderCtx, [rect]);\r\n            await this.benchmark.benchmark(`Render ${res.name} (${res.w}x${res.h})`, () => {\r\n                glCtx.gl.clear(glCtx.gl.COLOR_BUFFER_BIT);\r\n                frame.compose();\r\n            }, 200);\r\n            // Cleanup WebGL resources\r\n            frame.rprops.delete = true;\r\n            rect.rprops.delete = true;\r\n            // Lose the WebGL context to free resources\r\n            const loseContext = glCtx.gl.getExtension('WEBGL_lose_context');\r\n            if (loseContext) {\r\n                loseContext.loseContext();\r\n            }\r\n            // Remove canvas from memory\r\n            testCanvas.remove();\r\n        }\r\n    }\r\n    /**\r\n     * Test rectangle rendering performance\r\n     */\r\n    async testRectangleRendering() {\r\n        console.log('\\n=== Rectangle Rendering Performance ===\\n');\r\n        await this.shaderContext.init();\r\n        const rectangleCounts = [100, 500, 1000, 2000, 5000];\r\n        for (const count of rectangleCounts) {\r\n            const rectangles = [];\r\n            for (let i = 0; i < count; i++) {\r\n                const x = Math.random() * 800;\r\n                const y = Math.random() * 600;\r\n                const w = 16 + Math.random() * 32;\r\n                const h = 16 + Math.random() * 32;\r\n                rectangles.push(new _engine_source__WEBPACK_IMPORTED_MODULE_1__.Composite.Rectangle(this.glContext, this.shaderContext, { x, y, w, h }, {\r\n                    r: Math.random(),\r\n                    g: Math.random(),\r\n                    b: Math.random(),\r\n                    a: 1\r\n                }));\r\n            }\r\n            const frame = new _engine_source__WEBPACK_IMPORTED_MODULE_1__.Composite.Frame(this.glContext, this.shaderContext, rectangles);\r\n            await this.benchmark.benchmark(`Render ${count} rectangles`, () => {\r\n                this.glContext.gl.clear(this.glContext.gl.COLOR_BUFFER_BIT);\r\n                frame.compose();\r\n            }, 100);\r\n            for (let r of rectangles)\r\n                r.rprops.delete = true;\r\n            frame.rprops.delete = true;\r\n            // Allow GPU cleanup between iterations\r\n            await this.gcPause(100);\r\n        }\r\n    }\r\n    /**\r\n     * Test text rendering performance\r\n     */\r\n    async testTextRendering() {\r\n        console.log('\\n=== Text Rendering Performance ===\\n');\r\n        await this.shaderContext.init();\r\n        const textCounts = [10, 50, 100, 200];\r\n        for (const count of textCounts) {\r\n            const texts = [];\r\n            for (let i = 0; i < count; i++) {\r\n                texts.push(new _engine_source__WEBPACK_IMPORTED_MODULE_1__.Composite.Text(this.glContext, this.shaderContext, `Test Text ${i}`, {\r\n                    size: 16\r\n                }));\r\n            }\r\n            const frame = new _engine_source__WEBPACK_IMPORTED_MODULE_1__.Composite.Frame(this.glContext, this.shaderContext, texts);\r\n            await this.benchmark.benchmark(`Render ${count} text objects`, () => {\r\n                this.glContext.gl.clear(this.glContext.gl.COLOR_BUFFER_BIT);\r\n                frame.compose();\r\n            }, 100);\r\n            for (let t of texts)\r\n                t.rprops.delete = true;\r\n            frame.rprops.delete = true;\r\n            // Allow GPU cleanup between iterations\r\n            await this.gcPause(100);\r\n        }\r\n    }\r\n    /**\r\n     * Test shader switching overhead\r\n     */\r\n    async testShaderSwitching() {\r\n        console.log('\\n=== Shader Switching Performance ===\\n');\r\n        await this.shaderContext.init();\r\n        const switchCounts = [10, 50, 100];\r\n        for (const count of switchCounts) {\r\n            // Create images with different shaders to trigger switching\r\n            const images = [];\r\n            for (let i = 0; i < count; i++) {\r\n                const img = new _engine_source__WEBPACK_IMPORTED_MODULE_1__.Composite.Rectangle(this.glContext, this.shaderContext, { x: 0, y: 0, w: 16, h: 16 }, { r: 1, g: 0, b: 0, a: 1 });\r\n                img.rprops.shaderID = i % 2 === 0 ? 'normal' : 'reverser';\r\n                images.push(img);\r\n            }\r\n            await this.benchmark.benchmark(`Render ${count} objects with shader switching`, () => {\r\n                for (const img of images) {\r\n                    this.shaderContext.passShader(img, { x: 0, y: 0, w: 16, h: 16 }, {});\r\n                }\r\n            }, 100);\r\n        }\r\n    }\r\n    /**\r\n     * Test GL clear operations\r\n     */\r\n    async testClearOperations() {\r\n        console.log('\\n=== Clear Operations Performance ===\\n');\r\n        await this.benchmark.benchmark('GL clear operations', () => {\r\n            this.glContext.gl.clear(this.glContext.gl.COLOR_BUFFER_BIT);\r\n        }, 1000);\r\n        await this.benchmark.benchmark('GL clear with depth', () => {\r\n            this.glContext.gl.clear(this.glContext.gl.COLOR_BUFFER_BIT | this.glContext.gl.DEPTH_BUFFER_BIT);\r\n        }, 1000);\r\n    }\r\n    /**\r\n     * Test snap (sprite frame) composition\r\n     */\r\n    async testSnapComposition() {\r\n        console.log('\\n=== Snap Composition Performance ===\\n');\r\n        const partCounts = [5, 10, 20, 50, 500];\r\n        for (const count of partCounts) {\r\n            const parts = [];\r\n            for (let i = 0; i < count; i++) {\r\n                parts.push(new _engine_source__WEBPACK_IMPORTED_MODULE_1__.Composite.Rectangle(this.glContext, this.shaderContext, { x: i * 5, y: i * 5, w: 16, h: 16 }, { r: 1, g: 1, b: 1, a: 1 }));\r\n            }\r\n            const snap = new _engine_source__WEBPACK_IMPORTED_MODULE_1__.Composite.Snap(this.glContext, this.shaderContext, parts);\r\n            await this.benchmark.benchmark(`Compose snap with ${count} parts`, () => {\r\n                snap.compose();\r\n            }, 500);\r\n            // Cleanup\r\n            snap.rprops.delete = true;\r\n            for (const part of parts) {\r\n                part.rprops.delete = true;\r\n            }\r\n            await this.gcPause(100);\r\n        }\r\n    }\r\n    /**\r\n     * Measure memory usage during rendering\r\n     */\r\n    async testRenderingMemory() {\r\n        console.log('\\n=== Rendering Memory Usage ===\\n');\r\n        this.memory.takeSnapshot('before-render-objects');\r\n        const rectangles = [];\r\n        for (let i = 0; i < 1000; i++) {\r\n            rectangles.push(new _engine_source__WEBPACK_IMPORTED_MODULE_1__.Composite.Rectangle(this.glContext, this.shaderContext, { x: i, y: i, w: 32, h: 32 }, { r: 1, g: 0, b: 0, a: 1 }));\r\n        }\r\n        this.memory.takeSnapshot('after-1000-rectangles');\r\n        const frame = new _engine_source__WEBPACK_IMPORTED_MODULE_1__.Composite.Frame(this.glContext, this.shaderContext, rectangles);\r\n        this.memory.takeSnapshot('after-frame-creation');\r\n        for (let i = 0; i < 100; i++) {\r\n            frame.compose();\r\n        }\r\n        this.memory.takeSnapshot('after-100-compositions');\r\n        this.memory.printSnapshot('before-render-objects');\r\n        this.memory.printSnapshot('after-1000-rectangles');\r\n        this.memory.printSnapshot('after-frame-creation');\r\n        this.memory.printSnapshot('after-100-compositions');\r\n        const memUsed = this.memory.compare('before-render-objects', 'after-100-compositions');\r\n        console.log(`Total memory used: ${(memUsed / 1024 / 1024).toFixed(2)} MB`);\r\n    }\r\n    /**\r\n     * Create a rotating entity that updates its rotation each frame\r\n     */\r\n    createRotatingEntity(x, y) {\r\n        const rect = new _engine_source__WEBPACK_IMPORTED_MODULE_1__.Composite.Rectangle(this.glContext, this.shaderContext, { x: 0, y: 0, w: 32, h: 32 }, { r: 1, g: 0, b: 0, a: 1 });\r\n        const entity = new _engine_source__WEBPACK_IMPORTED_MODULE_1__.Bodies.Embodiment(rect);\r\n        entity.pos = { x, y };\r\n        entity.hitbox = { x: 0, y: 0, w: 32, h: 32 };\r\n        // Store rotation state\r\n        let rotation = 0;\r\n        // Override update to add rotation\r\n        const originalUpdate = entity.update.bind(entity);\r\n        entity.update = function () {\r\n            originalUpdate();\r\n            // Rotate entity\r\n            rotation += 0.05;\r\n            if (rotation > Math.PI * 2)\r\n                rotation -= Math.PI * 2;\r\n            // Apply rotation to frame\r\n            this.myFrame.rprops.rotation = rotation;\r\n        };\r\n        return entity;\r\n    }\r\n    /**\r\n     * Test rendering performance with rotating entities\r\n     */\r\n    async testRotatingEntities() {\r\n        console.log('\\n=== Rotating Entity Rendering Performance ===\\n');\r\n        await this.shaderContext.init();\r\n        const entityCounts = [10, 50, 100, 200];\r\n        for (const count of entityCounts) {\r\n            const entities = [];\r\n            for (let i = 0; i < count; i++) {\r\n                const x = (i % 20) * 40;\r\n                const y = Math.floor(i / 20) * 40;\r\n                entities.push(this.createRotatingEntity(x, y));\r\n            }\r\n            // Create frame with all entities\r\n            const frame = new _engine_source__WEBPACK_IMPORTED_MODULE_1__.Composite.Frame(this.glContext, this.shaderContext, entities.map(e => e.myFrame));\r\n            await this.benchmark.benchmark(`Render ${count} rotating entities`, () => {\r\n                // Update all entities (applies rotation)\r\n                for (let i = 0; i < entities.length; i++) {\r\n                    entities[i].update();\r\n                }\r\n                // Compose frame (renders with rotations)\r\n                this.glContext.gl.clear(this.glContext.gl.COLOR_BUFFER_BIT);\r\n                frame.compose();\r\n            }, 200);\r\n            // Clean up\r\n            frame.rprops.delete = true;\r\n        }\r\n        console.log('\\nComparing static vs rotating entities...\\n');\r\n        // Comparison test\r\n        const staticRects = [];\r\n        const rotatingEntities = [];\r\n        for (let i = 0; i < 100; i++) {\r\n            const x = (i % 10) * 40;\r\n            const y = Math.floor(i / 10) * 40;\r\n            staticRects.push(new _engine_source__WEBPACK_IMPORTED_MODULE_1__.Composite.Rectangle(this.glContext, this.shaderContext, { x, y, w: 32, h: 32 }, { r: 1, g: 0, b: 0, a: 1 }));\r\n            rotatingEntities.push(this.createRotatingEntity(x, y));\r\n        }\r\n        const staticFrame = new _engine_source__WEBPACK_IMPORTED_MODULE_1__.Composite.Frame(this.glContext, this.shaderContext, staticRects);\r\n        const rotatingFrame = new _engine_source__WEBPACK_IMPORTED_MODULE_1__.Composite.Frame(this.glContext, this.shaderContext, rotatingEntities.map(e => e.myFrame));\r\n        await this.benchmark.benchmark('Render 100 static rectangles', () => {\r\n            this.glContext.gl.clear(this.glContext.gl.COLOR_BUFFER_BIT);\r\n            staticFrame.compose();\r\n        }, 200);\r\n        await this.benchmark.benchmark('Render 100 rotating entities', () => {\r\n            for (const entity of rotatingEntities) {\r\n                entity.update();\r\n            }\r\n            this.glContext.gl.clear(this.glContext.gl.COLOR_BUFFER_BIT);\r\n            rotatingFrame.compose();\r\n        }, 200);\r\n        // Clean up\r\n        staticFrame.rprops.delete = true;\r\n        rotatingFrame.rprops.delete = true;\r\n    }\r\n    /**\r\n     * Test rectangle rendering capacity with FPS measurement\r\n     * Measures pure rendering performance without entity logic\r\n     */\r\n    async testRectangleCapacity() {\r\n        console.log('\\n=== Rectangle Rendering Capacity (60 FPS Target) ===\\n');\r\n        await this.shaderContext.init();\r\n        const rectangleCounts = [100, 500, 1000, 2000, 5000, 10000, 15000, 20000];\r\n        const targetFPS = 60;\r\n        const testDuration = 2000; // Test each count for 2 seconds\r\n        for (const count of rectangleCounts) {\r\n            // Create rectangles\r\n            const rectangles = [];\r\n            for (let i = 0; i < count; i++) {\r\n                const x = Math.random() * 800;\r\n                const y = Math.random() * 600;\r\n                const w = 16 + Math.random() * 16;\r\n                const h = 16 + Math.random() * 16;\r\n                rectangles.push(new _engine_source__WEBPACK_IMPORTED_MODULE_1__.Composite.Rectangle(this.glContext, this.shaderContext, { x, y, w, h }, {\r\n                    r: Math.random(),\r\n                    g: Math.random(),\r\n                    b: Math.random(),\r\n                    a: 1\r\n                }));\r\n            }\r\n            const frame = new _engine_source__WEBPACK_IMPORTED_MODULE_1__.Composite.Frame(this.glContext, this.shaderContext, rectangles);\r\n            // Measure FPS over time\r\n            const fps = await this.measureRectangleFPS(frame, testDuration);\r\n            const avgFrameTime = 1000 / fps;\r\n            const status = Math.round(fps) >= targetFPS ? ' PASS' : ' FAIL';\r\n            const color = Math.round(fps) >= targetFPS ? '\\x1b[32m' : '\\x1b[31m';\r\n            const reset = '\\x1b[0m';\r\n            console.log(`${color}${status}${reset} ${count} rectangles: ${fps.toFixed(2)} FPS (${avgFrameTime.toFixed(2)}ms per frame)`);\r\n            // Clean up\r\n            for (const rect of rectangles) {\r\n                rect.rprops.delete = true;\r\n            }\r\n            frame.rprops.delete = true;\r\n            await this.gcPause(100);\r\n            // Stop testing if we're significantly below target\r\n            if (fps < targetFPS * 0.5) {\r\n                console.log(`\\nStopping test - FPS dropped below ${(targetFPS * 0.5).toFixed(0)} FPS`);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Measure actual rendering FPS for rectangles using requestAnimationFrame\r\n     */\r\n    measureRectangleFPS(frame, durationMs) {\r\n        return new Promise((resolve) => {\r\n            let frameCount = 0;\r\n            const startTime = performance.now();\r\n            const renderLoop = (currentTime) => {\r\n                // Clear and render\r\n                this.glContext.gl.clear(this.glContext.gl.COLOR_BUFFER_BIT);\r\n                frame.compose();\r\n                frameCount++;\r\n                const elapsed = currentTime - startTime;\r\n                if (elapsed >= durationMs) {\r\n                    // Calculate average FPS\r\n                    const fps = (frameCount / elapsed) * 1000;\r\n                    resolve(fps);\r\n                }\r\n                else {\r\n                    requestAnimationFrame(renderLoop);\r\n                }\r\n            };\r\n            requestAnimationFrame(renderLoop);\r\n        });\r\n    }\r\n    /**\r\n     * Test entity rendering with FPS measurement to find frame drop threshold\r\n     * Uses actual Fauna entities to simulate real game performance\r\n     */\r\n    async testEntityCapacity() {\r\n        console.log('\\n=== Fauna Entity Rendering Capacity (60 FPS Target) ===\\n');\r\n        await this.shaderContext.init();\r\n        const entityCounts = [100, 500, 1000, 2000, 3000, 5000, 7500, 10000];\r\n        const targetFPS = 60;\r\n        const testDuration = 2000; // Test each count for 2 seconds\r\n        for (const count of entityCounts) {\r\n            // Create Fauna entities\r\n            const entities = [];\r\n            for (let i = 0; i < count; i++) {\r\n                const x = Math.random() * 800;\r\n                const y = Math.random() * 600;\r\n                entities.push(new TestFauna(this.glContext, this.shaderContext, { x, y }));\r\n            }\r\n            // Measure FPS over time with entity updates\r\n            const fps = await this.measureEntityFPS(entities, testDuration);\r\n            const avgFrameTime = 1000 / fps;\r\n            const status = Math.round(fps) >= targetFPS ? ' PASS' : ' FAIL';\r\n            const color = Math.round(fps) >= targetFPS ? '\\x1b[32m' : '\\x1b[31m';\r\n            const reset = '\\x1b[0m';\r\n            console.log(`${color}${status}${reset} ${count} entities: ${fps.toFixed(2)} FPS (${avgFrameTime.toFixed(2)}ms per frame)`);\r\n            // Clean up\r\n            for (const entity of entities) {\r\n                entity.destroy();\r\n            }\r\n            // Stop testing if we're significantly below target\r\n            if (fps < targetFPS * 0.5) {\r\n                console.log(`\\nStopping test - FPS dropped below ${(targetFPS * 0.5).toFixed(0)} FPS`);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Measure actual rendering FPS with entity updates using requestAnimationFrame\r\n     */\r\n    measureEntityFPS(entities, durationMs) {\r\n        return new Promise((resolve) => {\r\n            let frameCount = 0;\r\n            const startTime = performance.now();\r\n            const renderLoop = (currentTime) => {\r\n                // Update all entities (calls their update logic)\r\n                for (const entity of entities) {\r\n                    entity.update();\r\n                }\r\n                // Finalize entity states (movement, callbacks, etc.)\r\n                for (const entity of entities) {\r\n                    entity.finalize();\r\n                }\r\n                // Clear and render all entity frames\r\n                this.glContext.gl.clear(this.glContext.gl.COLOR_BUFFER_BIT);\r\n                for (const entity of entities) {\r\n                    entity.myFrame.compose();\r\n                }\r\n                frameCount++;\r\n                const elapsed = currentTime - startTime;\r\n                if (elapsed >= durationMs) {\r\n                    // Calculate average FPS\r\n                    const fps = (frameCount / elapsed) * 1000;\r\n                    resolve(fps);\r\n                }\r\n                else {\r\n                    requestAnimationFrame(renderLoop);\r\n                }\r\n            };\r\n            requestAnimationFrame(renderLoop);\r\n        });\r\n    }\r\n    /**\r\n     * Helper to allow garbage collection between heavy tests\r\n     */\r\n    async gcPause(ms = 100) {\r\n        return new Promise(resolve => setTimeout(resolve, ms));\r\n    }\r\n    /**\r\n     * Run all render performance tests\r\n     */\r\n    async runAll() {\r\n        console.log('Starting Render Performance Tests...');\r\n        await this.testClearOperations();\r\n        await this.gcPause();\r\n        await this.testRectangleRendering();\r\n        await this.gcPause();\r\n        await this.testTextRendering();\r\n        await this.gcPause();\r\n        await this.testFrameComposition();\r\n        await this.gcPause();\r\n        await this.testSnapComposition();\r\n        await this.gcPause();\r\n        await this.testRotatingEntities();\r\n        await this.gcPause();\r\n        await this.testRectangleCapacity();\r\n        await this.gcPause(500); // Longer pause after heavy test\r\n        await this.testEntityCapacity();\r\n        await this.gcPause(500); // Longer pause after heavy test\r\n        await this.testResolutionScaling();\r\n        await this.gcPause();\r\n        await this.testShaderSwitching();\r\n        await this.gcPause();\r\n        await this.testRenderingMemory();\r\n        this.benchmark.printResults();\r\n        console.log('\\nExporting results to JSON...');\r\n        const json = this.benchmark.exportJSON();\r\n        console.log(json);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./render-performance.ts?\n}");

/***/ }

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Check if module exists (development only)
/******/ 	if (__webpack_modules__[moduleId] === undefined) {
/******/ 		var e = new Error("Cannot find module '" + moduleId + "'");
/******/ 		e.code = 'MODULE_NOT_FOUND';
/******/ 		throw e;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
/******/ 
/******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module can't be inlined because the eval devtool is used.
/******/ var __webpack_exports__ = __webpack_require__("./index.ts");
/******/ const __webpack_exports__AssetPerformanceTests = __webpack_exports__.AssetPerformanceTests;
/******/ const __webpack_exports__ParserPerformanceTests = __webpack_exports__.ParserPerformanceTests;
/******/ const __webpack_exports__PerformanceTestRunner = __webpack_exports__.PerformanceTestRunner;
/******/ const __webpack_exports__PhysicsPerformanceTests = __webpack_exports__.PhysicsPerformanceTests;
/******/ const __webpack_exports__RenderPerformanceTests = __webpack_exports__.RenderPerformanceTests;
/******/ export { __webpack_exports__AssetPerformanceTests as AssetPerformanceTests, __webpack_exports__ParserPerformanceTests as ParserPerformanceTests, __webpack_exports__PerformanceTestRunner as PerformanceTestRunner, __webpack_exports__PhysicsPerformanceTests as PhysicsPerformanceTests, __webpack_exports__RenderPerformanceTests as RenderPerformanceTests };
/******/ 
